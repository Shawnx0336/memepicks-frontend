<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="SolDuel - A Solana-based social dueling game for degens. Stake SOL, guess the number, and win in 30-second live duels!">
    <meta name="keywords" content="Solana, SolDuel, crypto game, degen, staking, skill game">
    <meta name="author" content="YourName">
    <title>SolDuel - Degen Dueling Arena</title>

    <link rel="icon" type="image/png" href="favicon.png">

    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" as="style">

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/emoji-picker-element@1.10.0/dist/index.js" type="module"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.1/purify.min.js"></script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX'); // Replace with your actual GA_MEASUREMENT_ID
    </script>

    <style>
        /* General styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', sans-serif;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            position: relative; /* For dynamic background */
        }

        /* Dynamic Background - Opacity reduced to 0.03 */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://media.giphy.com/media/3o7bu3XilJ5BOiSGic/giphy.gif') repeat; /* Glitchy GIF */
            opacity: 0.03; /* Reduced opacity */
            pointer-events: none;
            z-index: -1;
        }

        /* Added subtle pattern overlay for more visual depth */
        #pattern-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://www.transparenttextures.com/patterns/carbon-fibre.png');
            opacity: 0.05;
            pointer-events: none;
            z-index: -1;
        }

        /* Added Visual Design Enhancements */
        .gradient-bg {
            background: linear-gradient(45deg, #0a0a0a 0%, #1a2b1a 100%);
        }
        .neon-border {
            border: 2px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            border-radius: 10px; /* Added rounded corners */
        }
        .loading-pulse {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        /* Neon Glow Effect */
        @keyframes neon-glow {
            0% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 20px #00ff00; }
            50% { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00; }
            100% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 20px #00ff00; }
        }

        /* Guess Animations */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        @keyframes glow {
            0% { box-shadow: 0 0 5px #00ff00; }
            50% { box-shadow: 0 0 20px #00ff00; }
            100% { box-shadow: 0 0 5px #00ff00; }
        }
        .shake {
            animation: shake 0.3s;
        }
        .glow {
            animation: glow 1s infinite;
        }

        /* Ticker animation for recent wins */
        @keyframes ticker {
            0% { transform: translateX(100%); }
            100% { transform: translateX(-100%); }
        }

        /* Added for flashing LIVE badge */
        @keyframes livePulse {
            0% { background: rgba(255, 0, 0, 0.8); box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
            50% { background: rgba(255, 0, 0, 1); box-shadow: 0 0 15px rgba(255, 0, 0, 0.8); }
            100% { background: rgba(255, 0, 0, 0.8); box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
        }

        /* Added for coin rain effect */
        @keyframes coinFall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0.8; }
        }

        /* Added for screen flash */
        @keyframes flash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Added for typing dots animation */
        @keyframes typingDots {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }

        /* Added for slide-in animation for live wins */
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Add subtle visual pulse to all chips/currency amounts */
        .sol-amount {
            animation: value-pulse 2s infinite alternate;
            text-shadow: 0 0 5px currentColor;
        }
        @keyframes value-pulse {
            0% { text-shadow: 0 0 3px currentColor; }
            100% { text-shadow: 0 0 8px currentColor; }
        }

        /* Improve level-up overlay */
        .level-up-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .level-up-content {
            background: linear-gradient(45deg, #1a1a1a, #262626);
            border: 3px solid gold;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 0 30px gold;
        }
        .level-up-content h2 {
            color: gold;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px gold;
        }
        .level-number {
            font-size: 5rem;
            color: #00ff00;
            margin: 1rem 0;
            text-shadow: 0 0 20px #00ff00;
            font-weight: bold;
        }
        .level-rewards {
            margin-top: 1.5rem;
        }
        .level-rewards p {
            color: white;
            margin-bottom: 0.5rem;
        }
        .level-rewards ul {
            list-style: none;
            margin: 1rem 0;
            padding: 0;
        }
        .level-rewards li {
            color: #00ff00;
            margin: 0.5rem 0;
            text-shadow: 0 0 5px #00ff00;
        }
        .level-rewards button {
            background: linear-gradient(45deg, gold, #ffc800);
            border: none;
            color: black;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 5px;
            margin-top: 1rem;
            cursor: pointer;
            box-shadow: 0 0 10px gold;
            transition: all 0.3s;
        }
        .level-rewards button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px gold;
        }

        /* Header */
        header {
            background: #1a1a1a;
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid #00ff00;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 2rem;
            padding-right: 2rem;
        }

        header h1 {
            font-size: 1.5rem;
            color: #00ff00;
            animation: neon-glow 2s infinite;
            flex-grow: 1; /* Allows title to take available space */
        }

        /* Header Buttons Container - Hidden on mobile, replaced by toggle */
        .header-buttons {
            display: flex;
            gap: 1rem;
        }
        @media (max-width: 768px) {
            .header-buttons {
                display: none; /* Hide individual buttons on mobile */
            }
        }

        /* Header Menu Toggle for Mobile */
        #header-menu-toggle {
            background: none;
            border: none;
            color: #00ff00;
            font-size: 1.5rem;
            cursor: pointer;
            display: none; /* Hidden on desktop */
        }
        @media (max-width: 768px) {
            #header-menu-toggle {
                display: block; /* Show on mobile */
            }
        }

        /* Header Dropdown Menu */
        #header-dropdown {
            position: fixed;
            top: 0; /* Adjusted to cover full screen */
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Darker overlay */
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            box-sizing: border-box;
            border: none; /* Remove modal-content border */
            box-shadow: none; /* Remove modal-content shadow */
            border-radius: 0; /* Remove modal-content border-radius */
        }
        #header-dropdown button, #header-dropdown input[type="range"] {
            width: 80%;
            max-width: 300px;
            padding: 15px;
            font-size: 1.2rem;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            text-align: center;
        }
        #header-dropdown button:hover {
            background: #00cc00;
        }
        #header-dropdown input[type="range"] {
            background: #333;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 5px;
        }
        #header-dropdown input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff00;
            cursor: pointer;
        }
        #header-dropdown input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ff00;
            cursor: pointer;
        }


        /* Wallet Connection */
        #wallet-section {
            text-align: center;
            padding: 1rem;
            background: #1a1a1a;
            border-bottom: 1px solid #00ff00;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap; /* Added for responsiveness */
        }

        #connect-wallet {
            background: #ff4500;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5); /* Added shadow */
        }

        #connect-wallet:hover {
            background: #ff6500;
        }

        #wallet-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        #wallet-address {
            font-size: 0.9rem;
            color: #00ff00;
        }

        #wallet-balance {
            font-size: 0.9rem;
            color: #00ff00;
        }

        #network-status {
            font-size: 0.8rem;
            color: #00ff00;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: red; /* Default offline */
            animation: none;
        }

        .status-dot.online {
            background-color: #00ff00;
            animation: pulse 1s infinite;
        }

        /* Main Content */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1rem;
        }

        /* Duel Arena */
        #duel-arena {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            position: relative; /* For player cards positioning */
            width: 100%; /* Added for responsiveness */
            max-width: 100%; /* Added for responsiveness */
            height: auto; /* Added for responsiveness */
            min-height: 400px; /* Adjust based on content */
            box-sizing: border-box; /* Added for responsiveness */
            overflow-x: hidden; /* Prevent horizontal scrolling */
            overflow-y: auto; /* Allow vertical scrolling if content overflows */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        #duel-arena h2 {
            font-size: 1.2rem;
            color: #00ff00;
            margin-bottom: 1rem;
        }

        /* Player Cards */
        .player-cards {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap; /* Added for responsiveness */
            gap: 1rem;
        }

        .player-card {
            background: #0d0d0d;
            border: 1px solid #00ff00;
            border-radius: 10px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 120px; /* Fixed width for consistency */
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transition: transform 0.3s ease-out; /* For victory/defeat animation */
            position: relative; /* For streak badge */
        }

        /* Player Card Pop */
        #player-card-you {
            box-shadow: 0 0 12px #00ff00;
        }
        #player-card-opponent {
            box-shadow: 0 0 12px #ff4500;
        }
        .vs-badge {
            margin: 10px 0; /* Adjusted margin */
        }


        .player-card.winner {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
        }
        .player-card.loser {
            transform: scale(0.95);
            opacity: 0.7;
        }


        .player-card .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #ff4500;
            object-fit: cover;
        }

        .player-card .username {
            font-size: 0.9rem;
            color: #fff;
        }

        .player-card .health-bar {
            width: 80%;
            height: 8px;
            background: #ff4500;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .player-card .health-bar-fill {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Represents 100% health */
            height: 100%;
            background: linear-gradient(to right, #00ff00, #00cc00);
            border-radius: 55px;
            transition: width 0.5s ease-out; /* Smooth health transitions */
        }

        .vs-badge {
            background: #ff4500;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
            animation: pulse 1s infinite alternate; /* Added pulse animation */
        }

        #duel-status {
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        #duel-timer {
            font-size: 1.8rem; /* Increased size */
            color: #ff4500;
            margin: 10px 0; /* Adjusted margin */
            font-weight: bold;
            animation: neon-glow 1s infinite alternate; /* Added glow */
            text-align: center; /* Added for responsiveness */
        }

        #guess-input {
            padding: 0.5rem;
            font-size: 1rem;
            width: 120px; /* Adjusted width */
            margin-right: 0.5rem;
            background: #333;
            color: #fff;
            border: 1px solid #00ff00;
            border-radius: 5px;
            text-align: center;
            -webkit-appearance: none; /* Removed default iOS styling */
            -moz-appearance: none;
            appearance: none;
            touch-action: manipulation; /* Improved touch responsiveness */
        }

        #guess-button {
            padding: 0.5rem 1rem;
            background: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            -webkit-appearance: none; /* Removed default iOS styling */
            -moz-appearance: none;
            appearance: none;
            touch-action: manipulation; /* Improved touch responsiveness */
        }

        #guess-button:hover {
            background: #00cc00;
            transform: translateY(-2px);
        }

        #duel-result {
            margin-top: 1rem;
            font-size: 1.1rem; /* Increased size */
            color: #00ff00;
            font-weight: bold;
        }

        /* Stake Selection */
        #stake-section {
            margin: 1rem 0;
            text-align: center;
        }

        #stake-amount {
            padding: 0.5rem;
            font-size: 1rem;
            background: #333;
            color: #fff;
            border: 1px solid #00ff00;
            border-radius: 5px;
            width: 100%; /* Added for responsiveness */
            padding: 8px; /* Adjusted padding */
            margin-bottom: 10px; /* Adjusted margin */
            box-sizing: border-box; /* Ensures padding is included in width */
            -webkit-appearance: none; /* Removed default iOS styling */
            -moz-appearance: none;
            appearance: none;
            touch-action: manipulation; /* Improved touch responsiveness */
        }

        /* Chat */
        #chat-section {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 1rem;
            height: 250px; /* Increased height */
            display: flex;
            flex-direction: column;
        }

        #chat-section h2 {
            font-size: 1.2rem;
            color: #00ff00;
            margin-bottom: 1rem;
        }

        #recent-wins {
            background: #1a1a1a;
            border-bottom: 1px solid #00ff00;
            padding: 0.5rem;
            font-size: 0.9rem;
            overflow: hidden;
            white-space: nowrap;
            margin-bottom: 1rem;
        }

        #wins-ticker {
            display: inline-block;
            animation: ticker 15s linear infinite;
        }
        #wins-ticker span {
            padding-right: 20px; /* Space between items */
        }

        #chat-messages {
            list-style: none;
            font-size: 0.9rem;
            flex-grow: 1; /* Allows messages to take available space */
            overflow-y: auto; /* Ensures scrollbar for messages */
            padding-right: 5px; /* Prevent scrollbar from overlapping text */
        }

        #chat-messages li {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #chat-input {
            width: 100%;
            padding: 0.5rem;
            background: #333;
            color: #fff;
            border: 1px solid #00ff00;
            border-radius: 5px;
            margin-top: 1rem;
        }

        emoji-picker {
            --background: #1a1a1a;
            --border-color: #00ff00;
            --button-hover-background: #00ff00;
            --button-active-background: #00cc00;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }
        #chat-messages li:hover .reaction-buttons {
            display: flex;
        }
        .reaction-buttons {
            display: none;
            gap: 0.3rem;
            margin-left: auto; /* Push reactions to the right */
        }
        .reaction-buttons button {
            background: none;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            padding: 0.2rem;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .reaction-buttons button:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        /* Leaderboard */
        #leaderboard-section {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 1rem;
        }

        #leaderboard-section h2 {
            font-size: 1.2rem;
            color: #00ff00;
            margin-bottom: 1rem;
        }

        #leaderboard-list {
            list-style: none;
            font-size: 0.9rem;
        }

        #leaderboard-list li {
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.2rem 0;
            border-bottom: 1px dashed #333; /* Subtle separator */
        }
        #leaderboard-list li:last-child {
            border-bottom: none;
        }
        #leaderboard-list li:first-child {
            color: #ffd700; /* Gold for #1 */
            font-weight: bold;
        }
        #leaderboard-list li:first-child::before {
            content: 'üèÜ '; /* Trophy emoji */
        }

        /* Footer */
        footer {
            background: #1a1a1a;
            padding: 1rem;
            text-align: center;
            border-top: 2px solid #00ff00;
            margin-top: auto; /* Pushes footer to the bottom */
        }

        footer p {
            font-size: 0.8rem;
            color: #888;
        }

        /* Modals and Toasts */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Hidden by default */
            overflow-y: auto; /* Allow scrolling if content overflows */
        }

        .modal-content {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            max-width: 400px;
            width: 90%;
            box-sizing: border-box; /* Ensures padding is included in width */
        }

        .modal-content h3 {
            color: #00ff00;
            margin-bottom: 1rem;
        }

        .modal-content p {
            margin-bottom: 1.5rem;
            font-size: 1rem;
        }

        .modal-content button {
            background: #ff4500;
            border: none;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .modal-content button:hover {
            background: #ff6500;
        }

        /* Profile Form Specific Styles */
        .profile-form label {
            display: block;
            margin: 0.5rem 0 0.2rem;
            color: #00ff00;
            text-align: left;
        }
        .profile-form input[type="text"],
        .profile-form input[type="file"],
        .profile-form textarea {
            width: 100%;
            padding: 0.5rem;
            background: #333;
            color: #fff;
            border: 1px solid #00ff00;
            border-radius: 5px;
            margin-bottom: 1rem;
        }
        .profile-form textarea {
            height: 80px;
            resize: vertical;
        }
        #avatar-preview {
            text-align: center;
            margin: 1rem 0;
        }
        #avatar-img {
            width: 80px; /* Increased size for preview */
            height: 80px;
            border-radius: 50%;
            border: 2px solid #ff4500;
            object-fit: cover;
        }

        /* Public Profile Modal Specific Styles */
        #public-profile-modal .modal-content img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #ff4500;
            object-fit: cover;
            margin-bottom: 1rem;
        }
        #public-profile-modal .modal-content div {
            text-align: left;
            margin-top: 1rem;
            padding-left: 1rem;
        }
        #public-profile-modal .modal-content p {
            margin-bottom: 0.5rem;
        }


        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .toast.show {
            opacity: 1;
        }

        /* Loading Spinner */
        .spinner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            border: 6px solid #f3f3f3; /* Light grey */
            border-top: 6px solid #00ff00; /* Green */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (min-width: 768px) {
            main {
                flex-direction: row;
                gap: 2rem;
            }

            #duel-arena, #chat-section, #leaderboard-section {
                flex: 1;
            }

            header h1 {
                font-size: 2rem;
            }

            #duel-arena h2, #chat-section h2, #leaderboard-section h2 {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 767px) {
            .player-cards {
                flex-direction: column;
            }
            .player-card {
                width: 80%; /* Make cards wider on small screens */
            }
        }

        /* Added for guess range indicator */
        .guess-range-container {
            position: relative;
            width: 80%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            margin: 1rem auto;
            overflow: hidden;
        }

        .guess-range-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ff4500);
            position: absolute;
            left: 0;
            top: 0;
            transition: all 0.3s ease-out;
        }

        .guess-marker {
            width: 4px;
            height: 100%;
            background: #fff;
            position: absolute;
            top: 0;
            left: 50%; /* Centered initially */
            transform: translateX(-50%);
            transition: all 0.3s ease-out;
            box-shadow: 0 0 5px rgba(255,255,255,0.7);
        }

        /* Heatmap styles - REMOVED */

        /* Level progress bar */
        #level-progress-container {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        #level-progress-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background: linear-gradient(90deg, #00aa00, #00ff00);
            transition: width 0.5s;
        }
        #level-progress-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 20px;
            font-size: 0.7rem;
            color: white;
        }

        /* Tooltip for VIP Room 3 - REMOVED */

        /* Mobile-Specific Optimizations */
        @media (max-width: 768px) {
            #duel-arena {
                padding: 5px;
                min-height: 300px;
            }
            /* Merged Live Badge + Spectator Count */
            .live-status-bar {
                display: block; /* Ensure it's block on mobile */
                position: absolute;
                top: 5px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.7);
                color: #ff4500;
                padding: 6px 12px;
                font-weight: bold;
                font-size: 0.9rem;
                border-radius: 8px;
                white-space: nowrap; /* Prevent wrapping */
                max-width: 90%; /* Ensure it fits */
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .guess-feedback {
                top: 50%;
                font-size: clamp(0.8rem, 3vw, 1.5rem);
                max-width: 90%; /* Prevent elements from being cut off */
                overflow: hidden;
                text-overflow: ellipsis;
            }
            /* Guessing Status Bubble */
            .guess-pill {
                position: fixed;
                bottom: 60px;
                right: 10px;
                background: #ff4500;
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-size: 0.75rem;
                animation: pulse 1.5s infinite;
                z-index: 90; /* Ensure it's above other content but below modals */
            }

            #stake-amount, #guess-input, #guess-button {
                font-size: 0.9rem;
                padding: 6px;
                width: 100%; /* Ensure full width on mobile */
            }
            #guess-section {
                padding: 5px;
            }
            #duel-timer {
                font-size: 1.2rem;
                margin: 5px 0;
            }
            .modal-content {
                width: 95%;
                padding: 15px;
                font-size: 0.9rem;
            }
            .modal-content h3 {
                font-size: 1.2rem;
            }
            .modal-content p {
                font-size: 0.9rem;
            }
            .modal-content button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
            /* Stack elements vertically within duel arena */
            #duel-arena > *:not(.player-cards):not(#duel-timer):not(#turn-indicator):not(.live-status-bar):not(.multiplier-badge):not(.guess-pill) {
                display: block;
                margin-bottom: 10px;
            }
        }

        /* CSS to disable animations */
        .no-animations * {
            animation: none !important;
            transition: none !important;
        }

        /* VIP Room Blur */
        #vip-room-1-lock, #vip-room-2-lock, #vip-room-3-lock {
            backdrop-filter: blur(3px);
            color: white;
        }
    </style>
</head>
<body class="gradient-bg">
    <div id="pattern-overlay"></div>

    <header>
        <h1>SolDuel - Degen Dueling Arena</h1>
        <button id="header-menu-toggle" aria-label="Open menu">
            <i class="fas fa-bars"></i>
        </button>
        <div class="header-buttons">
            <button id="profile-button" aria-label="Open profile">
                <i class="fas fa-user"></i>
            </button>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-volume-up" id="sound-icon" style="color: #00ff00;"></i>
                <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="1" aria-label="Volume slider" style="width: 80px;">
            </div>
            <button id="help-button" style="background: none; border: none; color: #00ff00; font-size: 1.5rem; cursor: pointer; transition: color 0.3s;">
                <i class="fas fa-question-circle"></i>
            </button>
        </div>
    </header>

    <div id="header-dropdown" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <button id="close-header-dropdown" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: #fff; font-size: 1.5rem; cursor: pointer;">
                <i class="fas fa-times"></i>
            </button>
            <button id="open-profile-from-dropdown">üë§ Profile</button>
            <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; width: 80%; max-width: 300px; margin: 10px auto;">
                <i class="fas fa-volume-up" id="sound-icon-dropdown" style="color: #00ff00;"></i>
                <input type="range" id="volume-slider-dropdown" min="0" max="1" step="0.1" value="1" aria-label="Volume slider">
            </div>
            <button id="open-help-from-dropdown">‚ùì Help</button>
        </div>
    </div>


    <div id="fomo-banner" style="background: linear-gradient(45deg, #ff4500, darkred); color: white; text-align: center; padding: 8px; font-weight: bold; display: flex; justify-content: center; align-items: center; gap: 10px;">
        <span>üî• MEGA JACKPOT EVENT ENDS IN:</span>
        <div id="jackpot-countdown" style="background: black; padding: 3px 8px; border-radius: 5px; font-family: monospace;">23:59:59</div>
        <button id="jackpot-button" style="background: gold; color: black; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">JOIN NOW</button>
    </div>

    <section id="wallet-section">
        <button id="connect-wallet" class="neon-border">Connect Wallet</button>
        <div id="wallet-info" style="display: none;">
            <p id="wallet-address"></p>
            <p id="wallet-balance" class="sol-amount"></p> <div id="network-status">
                <span class="status-dot" id="network-dot"></span>
                <span id="network-text">Offline</span>
            </div>
        </div>
    </section>

    <main>
        <section id="duel-arena" class="neon-border">
            <h2>Live Duel</h2>
            <div class="live-status-bar">üî¥ LIVE ¬∑ 32 degens watching</div>
            
            <div id="turn-indicator" style="position: absolute; top: 50px; left: 50%; transform: translateX(-50%); background: #00ff00; color: #000; padding: 5px 15px; border-radius: 5px; font-weight: bold; display: none;"></div>
            <div class="player-cards">
                <div class="player-card" id="player-card-you">
                    <img loading="lazy" src="https://placehold.co/60x60/00ff00/000000?text=YOU" class="avatar" alt="Your Avatar">
                    <span class="username">@You</span>
                    <div class="health-bar"><div class="health-bar-fill" id="player-health-fill"></div></div>
                    <div class="streak-badge" id="player-streak-badge" style="display: none; position: absolute; top: -15px; right: -15px; background: linear-gradient(45deg, #ff4500, #ff0000); color: white; border-radius: 50%; width: 30px; height: 30px; line-height: 30px; font-size: 0.8rem; font-weight: bold; box-shadow: 0 0 10px rgba(255, 69, 0, 0.7); animation: pulse 1s infinite alternate;">üî•3</div>
                </div>
                <div class="vs-badge">VS</div>
                <div class="player-card" id="player-card-opponent">
                    <img loading="lazy" src="https://placehold.co/60x60/ff4500/ffffff?text=OPP" class="avatar" alt="Opponent Avatar">
                    <span class="username">@CryptoChad</span>
                    <div class="health-bar"><div class="health-bar-fill" id="opponent-health-fill"></div></div>
                </div>
            </div>

            <p id="duel-status">Waiting for opponent...</p>
            <p id="duel-timer">00:30</p>
            <div id="stake-section" style="display: none;">
                <label for="stake-amount">Stake (SOL):</label>
                <select id="stake-amount">
                    <option value="0.01">0.01 SOL</option>
                    <option value="0.05">0.05 SOL</option>
                    <option value="0.1">0.1 SOL</option>
                </select>
            </div>
            <div id="guess-section" style="display: none;">
                </div>
            <p id="duel-result"></p>
            <button id="mode-toggle" style="position: absolute; bottom: 10px; right: 10px; background: #ff4500; color: #fff; border: none; padding: 0.5rem; border-radius: 5px;">Switch to Higher/Lower Mode</button>
        </section>

        <section id="chat-section" class="neon-border">
            <h2>Degen Chat <i class="fas fa-comments"></i></h2>
            <div id="recent-wins">
                <div id="wins-ticker">
                    <span>üî• @DegenKing won 0.19 SOL! &nbsp;</span>
                    <span>üöÄ @SolSniper won 0.095 SOL! &nbsp;</span>
                    <span>üí∞ @CryptoChad won 0.05 SOL! &nbsp;</span>
                    <span>üéâ @You won 0.01 SOL! &nbsp;</span>
                </div>
            </div>
            <div id="live-wins-container" style="max-height: 80px; overflow-y: auto; margin-bottom: 0.5rem; font-size: 0.8rem;">
                <ul id="live-wins" style="list-style: none; padding: 0; margin: 0;"></ul>
            </div>
            <ul id="chat-messages">
                <li>üî• @DegenKing: Let‚Äôs gooo!</li>
            </ul>
            <div id="emoji-picker-container" style="position: relative;">
                <input type="text" id="chat-input" placeholder="Type a message..." aria-label="Chat input">
                <button id="emoji-toggle" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #00ff00; font-size: 1.2rem; cursor: pointer;">üòÄ</button>
                <emoji-picker id="emoji-picker" style="display: none; position: absolute; bottom: 50px; right: 0; z-index: 100;"></emoji-picker>
            </div>
        </section>

        <section id="leaderboard-section" class="neon-border">
            <h2>Top Degens <i class="fas fa-trophy"></i></h2>
            <ul id="leaderboard-list">
                <li>1. @DegenKing - 15 wins</li>
                <li>2. @CryptoChad - 12 wins</li>
                <li>3. @SolSniper - 10 wins</li>
            </ul>
        </section>

        <section id="vip-rooms" class="neon-border" style="margin-top: 1rem; padding: 1rem; background: #1a1a1a; border: 2px solid #00ff00; border-radius: 10px; opacity: 0.9;">
            <h2 style="color: #00ff00; margin-bottom: 1rem;">VIP Rooms <i class="fas fa-crown" style="color: gold;"></i></h2>
            <ul style="list-style: none; font-size: 0.9rem;">
                <li style="margin-bottom: 0.8rem; padding: 0.5rem; background: rgba(50, 50, 50, 0.5); border-radius: 5px; position: relative; overflow: hidden; cursor: not-allowed;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><i class="fas fa-lock" style="color: gold; margin-right: 5px;"></i> 0.5 SOL High Rollers</span>
                        <span style="color: #ff4500;">12 players</span>
                    </div>
                    <div id="vip-room-1-lock" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; color: white;">Unlock at Level 5</div>
                </li>
                <li style="margin-bottom: 0.8rem; padding: 0.5rem; background: rgba(50, 50, 50, 0.5); border-radius: 5px; position: relative; overflow: hidden; cursor: not-allowed;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><i class="fas fa-lock" style="color: gold; margin-right: 5px;"></i> 1 SOL Degen VIP</span>
                        <span style="color: #ff4500;">5 players</span>
                    </div>
                    <div id="vip-room-2-lock" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; color: white;">Unlock at Level 10</div>
                </li>
                <li style="margin-bottom: 0.8rem; padding: 0.5rem; background: rgba(50, 50, 50, 0.5); border-radius: 5px; position: relative; overflow: hidden; cursor: not-allowed;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span><i class="fas fa-lock" style="color: gold; margin-right: 5px;"></i> 5 SOL Whale Club</span>
                        <span style="color: #ff4500;">2 players</span>
                    </div>
                    <div id="vip-room-3-lock" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; color: white;">
                        Invite Only
                    </div>
                </li>
            </ul>
            <button style="width: 100%; background: gold; color: black; border: none; padding: 0.7rem; border-radius: 5px; margin-top: 0.5rem; cursor: pointer; font-weight: bold;">UPGRADE NOW</button>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 SolDuel. All rights reserved.</p>
    </footer>

    <div id="profile-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Edit Profile</h3>
            <div class="profile-form">
                <label for="profile-username">Username:</label>
                <input type="text" id="profile-username" maxlength="20" placeholder="Enter username">
                <label for="profile-avatar">Avatar:</label>
                <input type="file" id="profile-avatar" accept="image/*">
                <div id="avatar-preview">
                    <img loading="lazy" id="avatar-img" src="https://placehold.co/60x60/00ff00/000000?text=YOU" alt="Avatar Preview">
                </div>
                <label for="profile-bio">Bio:</label>
                <textarea id="profile-bio" maxlength="100" placeholder="Tell us about yourself..."></textarea>
                <div style="margin-top: 1rem; text-align: left;">
                    <input type="checkbox" id="toggle-enhanced-notifications">
                    <label for="toggle-enhanced-notifications" style="display: inline; margin-left: 0.5rem;">Activity Notifications</label> </div>
            </div>
            <button id="save-profile-button" style="margin-top: 1rem;">Save</button>
        </div>
    </div>

    <div id="public-profile-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="public-profile-username"></h3>
            <img loading="lazy" id="public-profile-avatar" src="" alt="User Avatar">
            <p id="public-profile-bio"></p>
            <div style="text-align: left;">
                <p>Level: <span id="public-profile-level"></span></p>
                <p>Wins: <span id="public-profile-wins"></span></p>
                <p>Losses: <span id="public-profile-losses"></span></p>
                <p>Current Streak: <span id="public-profile-streak"></span></p>
            </div>
            <button id="close-public-profile-button">Close</button>
        </div>
    </div>

    <div id="transaction-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modal-title">Transaction Status</h3>
            <p id="modal-message">Confirming your transaction...</p>
            <button id="modal-close-button">OK</button>
        </div>
    </div>

    <div id="loading-spinner-overlay" class="spinner-overlay">
        <div class="spinner"></div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <div id="onboarding-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Welcome to SolDuel!</h3>
            <p>Guess the secret number between 1 and 100 within 30 seconds to win the SOL pot!</p>
            <p>Stake SOL, make your guess, and see if you can outsmart your opponent.</p>
            <p>Keep an eye on the timer and your health bar. Good luck, Degen!</p>
            <button id="start-onboarding-button">Let's Duel!</button>
            <button id="start-demo-duel-button" style="background: #00cc00; margin-top: 10px;">Try Demo Duel</button>
        </div>
    </div>

    <div id="daily-bonus-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>Daily Bonus!</h3>
            <p>Claim your daily reward of <span style="color: #00ff00; font-weight: bold;">0.005 SOL</span>!</p>
            <button id="claim-daily-bonus-button">Claim Bonus</button>
        </div>
    </div>

    <div id="level-progress-container">
        <div id="level-progress-fill"></div>
        <div id="level-progress-text">Level 1 (0%)</div>
    </div>

    <div class="guess-pill">üîÅ Classic | üë• 0 guessing</div>

    <script>
        // Simulated Solana Web3.js and Wallet Adapter (for demonstration purposes)
        // In a real application, you would import these from libraries or CDNs.
        const SOLANA_RPC_URL = 'https://api.devnet.solana.com'; // Example Devnet RPC

        // Mock Solana objects for demonstration
        class PublicKey {
            constructor(address) {
                this.address = address;
            }
            toBase58() {
                return this.address;
            }
        }

        class Connection {
            constructor(url) {
                this.url = url;
            }
            async getBalance(publicKey) {
                // Simulate fetching a balance
                console.log(`Simulating getBalance for ${publicKey.toBase58()}`);
                return Math.floor(Math.random() * 10000000000); // Random balance in lamports
            }
        }

        // Global connection instance
        const connection = new Connection(SOLANA_RPC_URL);

        // --- Google Analytics Event Tracking (Moved to top for scope) ---
        function trackEvent(eventName, category, label) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, { 'event_category': category, 'event_label': label });
            } else {
                console.warn('gtag is not defined. Google Analytics might not be loaded.');
            }
        }

        // DOM Elements
        const connectWalletButton = document.getElementById('connect-wallet');
        const walletInfoDiv = document.getElementById('wallet-info');
        const walletAddressDisplay = document.getElementById('wallet-address');
        const walletBalanceDisplay = document.getElementById('wallet-balance');
        const networkDot = document.getElementById('network-dot');
        const networkText = document.getElementById('network-text');
        const stakeSection = document.getElementById('stake-section');
        const stakeAmountSelect = document.getElementById('stake-amount'); // Get the select element
        const guessSection = document.getElementById('guess-section');
        const duelStatus = document.getElementById('duel-status');
        const duelTimer = document.getElementById('duel-timer');
        let guessInput = null; // Will be dynamically assigned
        let guessButton = null; // Will be dynamically assigned
        const duelResult = document.getElementById('duel-result');
        const transactionModal = document.getElementById('transaction-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseButton = document.getElementById('modal-close-button');
        const loadingSpinnerOverlay = document.getElementById('loading-spinner-overlay');
        const toastContainer = document.getElementById('toast-container');
        const soundIcon = document.getElementById('sound-icon');
        const volumeSlider = document.getElementById('volume-slider'); // New volume slider
        const playerCardYou = document.getElementById('player-card-you');
        const playerCardOpponent = document.getElementById('player-card-opponent');
        const playerHealthFill = document.getElementById('player-health-fill');
        const opponentHealthFill = document.getElementById('opponent-health-fill');
        
        // Profile Elements
        const profileButton = document.getElementById('profile-button');
        const profileModal = document.getElementById('profile-modal');
        const profileUsernameInput = document.getElementById('profile-username');
        const profileAvatarInput = document.getElementById('profile-avatar');
        const avatarPreviewImg = document.getElementById('avatar-img');
        const profileBioInput = document.getElementById('profile-bio');
        const saveProfileButton = document.getElementById('save-profile-button');
        const publicProfileModal = document.getElementById('public-profile-modal');
        const publicProfileUsername = document.getElementById('public-profile-username');
        const publicProfileAvatar = document.getElementById('public-profile-avatar');
        const publicProfileBio = document.getElementById('public-profile-bio');
        const publicProfileWins = document.getElementById('public-profile-wins');
        const publicProfileLosses = document.getElementById('public-profile-losses');
        const publicProfileStreak = document.getElementById('public-profile-streak');
        const publicProfileLevel = document.getElementById('public-profile-level');
        const closePublicProfileButton = document.getElementById('close-public-profile-button');
        const toggleEnhancedNotifications = document.getElementById('toggle-enhanced-notifications');

        // Chat Elements (re-bound after dynamic HTML update)
        let chatInput = document.getElementById('chat-input');
        let chatMessages = document.getElementById('chat-messages');
        let emojiToggle = document.getElementById('emoji-toggle');
        let emojiPicker = document.getElementById('emoji-picker');

        // Onboarding Elements
        const onboardingModal = document.getElementById('onboarding-modal');
        const startOnboardingButton = document.getElementById('start-onboarding-button');
        const startDemoDuelButton = document.getElementById('start-demo-duel-button'); // New: Demo Duel button
        const helpButton = document.getElementById('help-button'); // New: Help button

        // VIP Room Lock Elements
        const vipRoom1Lock = document.getElementById('vip-room-1-lock');
        const vipRoom2Lock = document.getElementById('vip-room-2-lock');
        const vipRoom3Lock = document.getElementById('vip-room-3-lock');

        // Level Progress Bar Elements
        const levelProgressContainer = document.getElementById('level-progress-container');
        const levelProgressFill = document.getElementById('level-progress-fill');
        const levelProgressText = document.getElementById('level-progress-text');

        // Header Dropdown Elements
        const headerMenuToggle = document.getElementById('header-menu-toggle');
        const headerDropdown = document.getElementById('header-dropdown');
        const closeHeaderDropdown = document.getElementById('close-header-dropdown');
        const openProfileFromDropdown = document.getElementById('open-profile-from-dropdown');
        const volumeSliderDropdown = document.getElementById('volume-slider-dropdown');
        const soundIconDropdown = document.getElementById('sound-icon-dropdown');
        const openHelpFromDropdown = document.getElementById('open-help-from-dropdown');

        // Merged Live Status Bar
        const liveStatusBar = document.querySelector('.live-status-bar');

        // Guessing Status Bubble
        const guessPill = document.querySelector('.guess-pill');


        // Game State Variables
        let isWalletConnected = false;
        let duelInProgress = false;
        let timerInterval;
        let timeLeft = 30;
        let targetNumber = Math.floor(Math.random() * 100) + 1; // Simulated hidden number
        let currentGuessCount = 0;
        let opponentGuessCount = 0;
        let userPublicKey = null; // To store the connected wallet's public key
        let currentVolume = 1; // Initial volume for sound control
        let streakProtectionAvailable = false;
        let minGuessRange = 1; // Player's current min guess range for Classic mode
        let maxGuessRange = 100; // Player's current max guess range for Classic mode
        let opponentMinGuessRange = 1; // Opponent's current min guess range for Classic mode
        let opponentMaxGuessRange = 100; // Opponent's current max guess range for Classic mode
        let gameMode = 'guess'; // 'guess', 'higher_lower' (only these two now)
        let guessHistory = []; // For heatmap - REMOVED, no longer needed

        // Turn-based variables
        let currentTurn = 'player'; // 'player' or 'opponent'
        let turnTimer; // For Speed Round mode - REMOVED, no longer needed

        // Higher or Lower mode specific ranges
        let playerRange = { min: 1, max: 100 };
        let opponentRange = { min: 1, max: 100 };

        // Notification Queue
        let notificationQueue = [];
        let notificationPlaying = false;

        // Store original simulateOpponentGuesses for first win guarantee
        let originalSimulateOpponentGuesses;

        // Profile State
        let userProfile = {
            username: '@You',
            avatar: 'https://placehold.co/60x60/00ff00/000000?text=YOU',
            bio: 'New degen in town!',
            wins: 0,
            losses: 0,
            streak: 0,
            level: 1, // Added for leveling system
            currentLossStreak: 0,
            freeEntryAvailable: false,
            streakProtectionUsed: false,
            enhancedNotifications: true, // New setting for behavioral manipulation toggle
            behavioralData: {
                preferredStakeAmount: null,
                responseToNearMisses: 0,
                timeSpentThinking: 0,
                chaseRatio: 0,
                lastActive: Date.now()
            },
            hasWonFirst: false // New: Track if user has won their first game
        };

        // --- Utility Functions ---

        /**
         * Debounces a function call, ensuring it's only executed after a specified delay.
         * Useful for limiting the rate of function calls triggered by events like resizing or scrolling.
         * @param {Function} func - The function to debounce.
         * @param {number} wait - The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        /**
         * Simulates detecting a Solana wallet (e.g., Phantom).
         * In a real app, this would check `window.solana`.
         * @returns {object|null} A mock provider object or null if not found.
         */
        async function detectWallet() {
            // Simulate a delay for wallet detection
            await new Promise(resolve => setTimeout(resolve, 500));
            // In a real scenario, you'd check `if (window.solana && window.solana.isPhantom)`
            // For this demo, we always "detect" a wallet.
            return {
                connect: async () => {
                    // Simulate connection success
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return { publicKey: new PublicKey('0x123...abc') }; // Mock public key
                },
                disconnect: async () => {
                    // Simulate disconnection
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            };
        }

        /**
         * Updates the displayed wallet balance.
         * @param {number} lamports - The balance in lamports.
         */
        function updateBalanceDisplay(lamports) {
            const solBalance = lamports / 1000000000; // Convert lamports to SOL
            walletBalanceDisplay.textContent = `Balance: ${solBalance.toFixed(4)} SOL`;
        }

        /**
         * Shows a toast notification for errors or messages.
         * @param {string} message - The message to display.
         * @param {string} type - 'error' (red), 'success' (green), or 'warning' (orange).
         * @param {boolean} forceShow - If true, shows even if enhanced notifications are off.
         */
        function showToast(message, type = 'error', forceShow = false) {
            if (!userProfile.enhancedNotifications && !forceShow && type !== 'error') {
                return; // Do not show non-error enhanced toasts if setting is off
            }
            const toast = document.createElement('div');
            toast.classList.add('toast');
            if (type === 'success') {
                toast.style.backgroundColor = 'rgba(0, 255, 0, 0.8)';
                toast.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
            } else if (type === 'warning') {
                toast.style.backgroundColor = 'rgba(255, 165, 0, 0.8)'; /* Orange for warning */
                toast.style.boxShadow = '0 0 10px rgba(255, 165, 0, 0.5)';
            }
            toast.textContent = message;
            toastContainer.appendChild(toast);

            // Show and then hide after a delay
            setTimeout(() => {
                toast.classList.add('show');
            }, 10); // Small delay to trigger transition

            setTimeout(() => {
                toast.classList.remove('show');
                toast.addEventListener('transitionend', () => toast.remove());
            }, 3000);
        }

        /**
         * Queues a notification to be displayed.
         * @param {string} type - The type of notification (e.g., 'lastWin', 'welcomeBack', 'toast').
         * @param {object} data - Data associated with the notification.
         */
        function queueNotification(type, data) {
            notificationQueue.push({ type, data });
            if (!notificationPlaying) {
                playNextNotification();
            }
        }

        /**
         * Plays the next notification in the queue.
         */
        function playNextNotification() {
            if (notificationQueue.length === 0) {
                notificationPlaying = false;
                return;
            }

            notificationPlaying = true;
            const notification = notificationQueue.shift();

            switch (notification.type) {
                case 'lastWin':
                    showLastWinPopup(notification.data);
                    break;
                case 'welcomeBack':
                    showWelcomeBackPopup(notification.data);
                    break;
                case 'toast':
                    showToast(notification.data.message, notification.data.type, notification.data.forceShow);
                    break;
                // Add other notification types here
            }

            // Wait before showing next notification
            setTimeout(playNextNotification, 30000); // 30-second delay between major notifications
        }

        /**
         * Shows the loading spinner overlay.
         */
        function showLoading() {
            loadingSpinnerOverlay.style.display = 'flex';
        }

        /**
         * Hides the loading spinner overlay.
         */
        function hideLoading() {
            loadingSpinnerOverlay.style.display = 'none';
        }

        /**
         * Shows the transaction confirmation modal.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message to display in the modal.
         */
        function showTransactionModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message; // Use innerHTML to allow for share button
            transactionModal.style.display = 'flex';
        }

        /**
         * Hides the transaction confirmation modal.
         */
        function hideTransactionModal() {
            transactionModal.style.display = 'none';
        }

        /**
         * Plays a simple sound effect.
         * @param {string} effect - 'win', 'lose', 'guess', 'connect', 'nearMiss', 'background_loop', 'level_up', 'jackpot_spin', 'crowd_cheer'.
         */
        const soundEffects = {
            win: [
                'https://www.myinstants.com/media/sounds/slot-machine-winner.mp3',
                'https://www.myinstants.com/media/sounds/winner.mp3',
                'https://www.myinstants.com/media/sounds/victory.mp3'
            ],
            lose: [
                'https://www.myinstants.com/media/sounds/game-over.mp3',
                'https://www.myinstants.com/media/sounds/fail.mp3',
                'https://www.myinstants.com/media/sounds/lose.mp3'
            ],
            guess: [
                'https://www.myinstants.com/media/sounds/click.mp3',
                'https://www.soundjay.com/buttons/sounds/button-10.mp3'
            ],
            connect: ['https://www.myinstants.com/media/sounds/cha-ching.mp3'],
            nearMiss: ['https://freesound.org/data/previews/331/331912_3248244-lq.mp3'],
            background_loop: ['https://www.soundjay.com/ambient/sounds/futuristic-ambient-1.mp3'],
            level_up: ['https://www.soundjay.com/misc/sounds/success-01.mp3'],
            jackpot_spin: ['https://www.myinstants.com/media/sounds/slot-machine.mp3'],
            crowd_cheer: ['https://www.myinstants.com/media/sounds/crowd-cheer.mp3']
        };

        let backgroundAudio = null; // Declare backgroundAudio globally

        function playSound(effect, winAmount = 0) { // Added winAmount for conditional crowd cheer
            // Sound is now controlled by volume slider, not a mute toggle
            if (currentVolume === 0) return;

            if (!hasUserInteracted) {
                console.log(`Sound effect '${effect}' blocked: User has not interacted yet.`);
                return;
            }

            const soundArray = soundEffects[effect] || [];
            const soundUrl = soundArray[Math.floor(Math.random() * soundArray.length)] || '';

            if (!soundUrl) return;

            let audio = new Audio(soundUrl);
            audio.volume = currentVolume; // Set volume
            audio.preload = 'none'; // Lazy load audio
            let panValue = 0; // Center by default

            switch (effect) {
                case 'win':
                    panValue = -0.8; // Left ear (winning from your side)
                    if (winAmount >= 0.5) { // Crowd cheer for big wins
                        const crowdCheer = new Audio(soundEffects.crowd_cheer[0]);
                        crowdCheer.volume = currentVolume; // Set volume for crowd cheer
                        crowdCheer.preload = 'none'; // Lazy load audio
                        crowdCheer.play().catch(e => console.error("Error playing crowd cheer:", e));
                    }
                    break;
                case 'lose':
                    panValue = 0.8; // Right ear (losing from opponent side)
                    break;
                case 'guess':
                    panValue = Math.random() * 1.6 - 0.8; // Between -0.8 and 0.8
                    break;
            }

            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaElementSource(audio);
                const panner = audioCtx.createStereoPanner();
                panner.pan.value = panValue;
                source.connect(panner);
                panner.connect(audioCtx.destination);
                audio.play().catch(e => console.error("Error playing sound:", e));
            } catch (e) {
                audio.play().catch(e => console.error("Error playing sound (fallback):", e)); // More specific error
            }
        }

        /**
         * Plays the background music loop.
         * This function should be called after a user interaction.
         */
        function playBackgroundMusic() {
            if (currentVolume === 0 || !hasUserInteracted) return;
            if (!backgroundAudio) {
                backgroundAudio = new Audio(soundEffects.background_loop[0]);
                backgroundAudio.loop = true;
                backgroundAudio.volume = 0.2 * currentVolume; // Adjust background volume by slider
                backgroundAudio.preload = 'none'; // Lazy load audio
            }
            backgroundAudio.play().catch(e => console.error("Error playing background music:", e));
        }

        /**
         * Updates the network status indicator.
         * @param {boolean} online - True if online, false if offline.
         */
        function updateNetworkStatus(online) {
            if (online) {
                networkDot.classList.add('online');
                networkText.textContent = 'Online';
            } else {
                networkDot.classList.remove('online');
                networkText.textContent = 'Offline';
            }
        }

        /**
         * Sanitizes string input to prevent XSS attacks using DOMPurify.
         * @param {string} text - The input string.
         * @returns {string} The sanitized string.
         */
        function sanitizeInput(text) {
            return DOMPurify.sanitize(text);
        }

        /**
         * Updates the health bar visually.
         * @param {HTMLElement} healthBarFillElement - The fill element of the health bar.
         * @param {number} percentage - The health percentage (0-100).
         * @param {boolean} isPlayer - True if it's the player's health bar.
         */
        function updateHealthBar(healthBarFillElement, percentage, isPlayer = false) {
            // Original logic for health bar update based on guess count for player
            // and fixed amount for opponent in classic mode.
            // This is now mainly used for 'wrong' guesses in Higher/Lower mode.
            if (gameMode === 'guess' && isPlayer) {
                // Less harsh early guesses
                percentage = Math.max(0, percentage - (currentGuessCount <= 3 ? 3 : 5));
            } else if (gameMode === 'guess' && !isPlayer) {
                // Opponent's health increases on player's correct guess, decreases on player's wrong guess
                // This logic is now handled more directly in simulateOpponentGuess for clarity.
            }
            healthBarFillElement.style.transition = isPlayer ? 'width 0.3s ease-in' : 'width 0.8s ease-out';
            healthBarFillElement.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
        }

        /**
         * Updates the live status bar with spectator count.
         */
        const updateLiveStatusBar = debounce(() => {
            const count = Math.floor(Math.random() * 50) + 20;
            liveStatusBar.textContent = `üî¥ LIVE ¬∑ ${count} degens watching`;
        }, 5000); // Debounce to prevent frequent DOM updates

        /**
         * Updates the guessing status bubble, optionally based on enhanced notifications setting.
         */
        function updateGuessPill() {
            if (!userProfile.enhancedNotifications) {
                if (guessPill) guessPill.style.display = 'none';
                return;
            }

            if (guessPill) {
                guessPill.style.display = 'block';
                const activeGuessers = Math.floor(Math.random() * 20) + 5; // Simulate active guessers
                let modeText = '';
                if (gameMode === 'guess') {
                    modeText = 'Classic';
                } else if (gameMode === 'higher_lower') {
                    modeText = 'Higher/Lower';
                }
                guessPill.textContent = `üîÅ ${modeText} | üë• ${activeGuessers} guessing`;
            }
        }

        /**
         * Simulates typing in chat, optionally based on enhanced notifications setting.
         */
        function simulateTyping() {
            if (!duelInProgress || !userProfile.enhancedNotifications) return;

            const typingIndicator = document.createElement('li');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.innerHTML = '<span style="color: gray;">@CryptoChad is typing<span class="typing-dots">...</span></span>';
            typingIndicator.style.opacity = '0.7';

            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .typing-dots { animation: typingDots 1.5s infinite; }
                @keyframes typingDots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
            `;
            document.head.appendChild(styleElement);

            chatMessages.appendChild(typingIndicator);

            setTimeout(() => {
                typingIndicator.remove();
                if (Math.random() > 0.5 && duelInProgress) {
                    const fakeMessages = [
                        "üí∞ @CryptoChad: Easiest SOL of my life",
                        "üî• @DegenKing: This app is addictive af",
                        "üöÄ @SolSniper: Just 10x'd my stack today",
                        "ü§ë @CryptoChad: Who's betting 0.5 SOL?",
                        "üéØ @DegenKing: I'm on a 7-win streak right now!"
                    ];
                    addChatMessage(fakeMessages[Math.floor(Math.random() * fakeMessages.length)]);
                }
            }, 2000 + Math.random() * 3000);
        }

        /**
         * Shows a popup with information about the last win.
         */
        function showLastWinPopup() {
            const lastWin = localStorage.getItem('lastWin');
            const lastWinAmount = localStorage.getItem('lastWinAmount');
            const lastWinTime = localStorage.getItem('lastWinTime');

            if (lastWin && lastWinAmount && lastWinTime) {
                const timeAgo = Math.round((Date.now() - parseInt(lastWinTime)) / 3600000);

                if (timeAgo > 0 && timeAgo < 24) {
                    const lastWinModal = document.createElement('div');
                    lastWinModal.className = 'modal-overlay';
                    lastWinModal.innerHTML = `
                        <div class="modal-content" style="border: 3px solid gold; background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);">
                            <h3 style="color: gold; text-shadow: 0 0 10px yellow;">YOU'RE ON FIRE!</h3>
                            <p style="font-size: 1.2rem; margin: 20px 0;">You won <span style="color: #00ff00; font-weight: bold; font-size: 1.5rem;">${lastWinAmount} SOL</span> ${timeAgo} hour${timeAgo > 1 ? 's' : ''} ago!</p>
                            <p style="margin-bottom: 20px; color: #aaa;">Hot players are winning <span style="color: #00ff00;">2x more</span> right now. Don't miss out!</p>
                            <button style="background: linear-gradient(45deg, #ff4500, #ff6a00); padding: 15px 30px; font-size: 1.2rem; margin-top: 10px; animation: pulse 1s infinite alternate;">PLAY AGAIN</button>
                        </div>
                    `;
                    document.body.appendChild(lastWinModal);

                    const closeButton = lastWinModal.querySelector('button');
                    closeButton.addEventListener('click', () => {
                        lastWinModal.remove();
                        if (isWalletConnected) {
                            startDuel();
                        } else {
                            connectWalletButton.click();
                        }
                    });

                    // Removed direct setTimeout, now managed by notification queue
                }
            }
        }

        /**
         * Shows a welcome back popup with a bonus.
         */
        function showWelcomeBackPopup() {
            const welcomeBackModal = document.createElement('div');
            welcomeBackModal.className = 'modal-overlay';
            welcomeBackModal.innerHTML = `
                <div class="modal-content" style="border: 3px solid #00ff00; background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);">
                    <h3 style="color: #00ff00; text-shadow: 0 0 10px #00ff00;">WELCOME BACK!</h3>
                    <p style="font-size: 1.2rem; margin: 20px 0;">We've missed you! Here's a ${userProfile.username == '@You' ? 'newcomer' : 'loyalty'} bonus:<br><br><span style="color: #00ff00; font-size: 1.3rem; font-weight: bold;">+0.02 SOL</span></p><button id="claim-welcome-bonus" style="background: #00ff00; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">CLAIM & PLAY</button></div>
            `;
            document.body.appendChild(welcomeBackModal);

            document.getElementById('claim-welcome-bonus').addEventListener('click', () => {
                const currentBalance = parseFloat(walletBalanceDisplay.textContent.split(': ')[1]) || 0;
                updateBalanceDisplay((currentBalance + 0.02) * 1000000000);
                queueNotification('toast', { message: '0.02 SOL bonus claimed!', type: 'success', forceShow: true });
                welcomeBackModal.remove();
                startDuel();
            });
        }

        /**
         * Shows a modal by its ID.
         * @param {string} modalId - The ID of the modal element.
         */
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'flex';
                // Find first focusable element and focus it for accessibility
                const focusableElements = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                if (focusableElements.length > 0) {
                    focusableElements[0].focus();
                }
            }
        }

        /**
         * Hides a modal by its ID.
         * @param {string} modalId - The ID of the modal element.
         */
        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        }

        /**
         * Generates fake live win notifications, optionally based on enhanced notifications setting.
         */
        function generateWinNotification() {
            if (!document.getElementById('live-wins') || !userProfile.enhancedNotifications) return;

            const users = ['@CryptoChad', '@DegenKing', '@SolSniper', '@Satoshi69', '@MoonGirl', '@LamboKid', '@YieldFarmer'];
            const amounts = [0.05, 0.1, 0.2, 0.5, 0.95, 1.2];
            const timeframes = ['just now', '5s ago', '10s ago', '15s ago', '30s ago'];
            const reactions = ['üî•', 'üöÄ', 'üí∞', 'ü§ë', 'üéØ', 'üíé', 'üëë'];

            const user = users[Math.floor(Math.random() * users.length)];
            const amount = amounts[Math.floor(Math.random() * amounts.length)];
            const timeframe = timeframes[Math.floor(Math.random() * timeframes.length)];
            const reaction = reactions[Math.floor(Math.random() * reactions.length)];

            const winItem = document.createElement('li');
            winItem.style.cssText = 'padding: 3px 5px; border-left: 2px solid #00ff00; margin-bottom: 3px; animation: slideIn 0.3s ease-out;';
            winItem.innerHTML = `<span style="color: #00ff00;">${reaction} ${user}</span> won <span style="color: #ff4500; font-weight: bold;">${amount} SOL</span> <span style="color: #888; font-size: 0.7rem;">${timeframe}</span>`;

            const liveWinsList = document.getElementById('live-wins');
            liveWinsList.insertBefore(winItem, liveWinsList.firstChild);

            if (liveWinsList.children.length > 5) {
                liveWinsList.removeChild(liveWinsList.lastChild);
            }

            const style = document.createElement('style');
            style.textContent = `@keyframes slideIn { from { transform: translateX(-20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }`;
            document.head.appendChild(style);

            if (Math.random() < 0.2) {
                setTimeout(() => {
                    const bigWinItem = document.createElement('li');
                    bigWinItem.style.cssText = 'padding: 5px; background: linear-gradient(45deg, rgba(255, 215, 0, 0.2), rgba(255, 69, 0, 0.2)); border-radius: 5px; margin: 5px 0; animation: pulse 1s infinite alternate, slideIn 0.5s ease-out;';
                    bigWinItem.innerHTML = `<span style="color: gold; font-weight: bold;">üèÜ MASSIVE WIN! @WhaleAlert</span> just won <span style="color: #ff4500; font-weight: bold; font-size: 1.1em;">5.2 SOL</span>`;

                    liveWinsList.insertBefore(bigWinItem, liveWinsList.firstChild);

                    const flashOverlay = document.createElement('div');
                    flashOverlay.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background-color: rgba(255, 215, 0, 0.1); z-index: 999; pointer-events: none; animation: flash 0.5s;
                    `;
                    document.body.appendChild(flashOverlay);
                    setTimeout(() => flashOverlay.remove(), 500);
                }, 1000);
            }
        }

        /**
         * Schedules the next fake win notification.
         */
        function scheduleNextWinNotification() {
            const delay = 3000 + Math.random() * 7000;
            setTimeout(() => {
                generateWinNotification();
                scheduleNextWinNotification();
            }, delay);
        }

        /**
         * Updates the FOMO jackpot countdown.
         */
        function updateJackpotCountdown() {
            const countdownElement = document.getElementById('jackpot-countdown');
            const now = new Date();
            const endOfDay = new Date();
            endOfDay.setHours(23, 59, 59, 999);
            let timeLeft = endOfDay - now;

            const hours = Math.floor(timeLeft / (1000 * 60 * 60)).toString().padStart(2, '0');
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60)).toString().padStart(2, '0');
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000).toString().padStart(2, '0');

            countdownElement.textContent = `${hours}:${minutes}:${seconds}`;

            if (hours === '00') {
                countdownElement.style.color = 'red';
                countdownElement.style.animation = 'pulse 0.5s infinite alternate';
            }
        }

        /**
         * Updates the visual guess range indicator using requestAnimationFrame for smoothness.
         * @param {number} min - The current minimum possible number.
         * @param {number} max - The current maximum possible number.
         * @param {number} lastGuess - The player's last guess.
         * @param {string} prefix - 'player' or 'opponent' to target the correct elements.
         */
        function updateGuessRangeIndicator(min, max, lastGuess, prefix = 'player') {
            const totalRange = 100;
            const fillWidth = ((max - min) / totalRange) * 100;
            const fillLeft = ((min - 1) / totalRange) * 100; // Adjust for 1-100 range

            const rangeFillElement = document.getElementById(`${prefix}-guess-range-fill`);
            const markerElement = document.getElementById(`${prefix}-guess-marker`);

            if (rangeFillElement) {
                requestAnimationFrame(() => {
                    rangeFillElement.style.width = `${fillWidth}%`;
                    rangeFillElement.style.left = `${fillLeft}%`;
                });
            }
            if (markerElement && lastGuess) {
                const markerPosition = ((lastGuess - 1) / totalRange) * 100;
                requestAnimationFrame(() => {
                    markerElement.style.left = `${markerPosition}%`;
                });
            }
        }

        /**
         * Updates the heatmap to show guess distribution.
         * @param {number} guess - The current guess to add to the history.
         * Removed as per user request.
         */
        // function updateGuessHeatMap(guess) { ... }

        /**
         * Updates the level progress bar.
         */
        function updateLevelProgress() {
            const winsNeededForNextLevel = (userProfile.level * 2) - userProfile.wins; // Assuming 2 wins per level
            const progressInCurrentLevel = userProfile.wins % 2; // 0 or 1
            const percentage = progressInCurrentLevel * 50; // 0% or 50%

            levelProgressFill.style.width = `${percentage}%`;
            levelProgressText.textContent = `Level ${userProfile.level} (${percentage}%)`;

            // Update VIP room lock status based on level
            if (userProfile.level >= 5) {
                if (vipRoom1Lock) vipRoom1Lock.style.display = 'none';
            } else {
                if (vipRoom1Lock) vipRoom1Lock.textContent = `Unlock at Level 5 (Current: ${userProfile.level})`;
            }
            if (userProfile.level >= 10) {
                if (vipRoom2Lock) vipRoom2Lock.style.display = 'none';
            } else {
                if (vipRoom2Lock) vipRoom2Lock.textContent = `Unlock at Level 10 (Current: ${userProfile.level})`;
            }
            // VIP Room 3 "Invite Only" remains hardcoded.
        }

        // Define a function to finalize the duel ending - MOVED TO GLOBAL SCOPE
        function endDuel(playerWon) {
            clearInterval(timerInterval);
            // clearInterval(turnTimer); // Clear turn timer for Speed Round - REMOVED
            duelInProgress = false;
            guessSection.style.display = 'none';
            document.getElementById('turn-indicator').style.display = 'none'; // Hide turn indicator

            // Restore original opponent behavior if it was overridden for first win guarantee
            if (originalSimulateOpponentGuesses) {
                simulateOpponentGuess = originalSimulateOpponentGuesses;
                originalSimulateOpponentGuesses = null;
            }

            let resultMessage = '';
            let modalTitleText = '';
            const currentStakeAmount = parseFloat(stakeAmountSelect.value);

            if (playerWon) {
                const winAmount = currentStakeAmount * (window.currentPayoutMultiplier || 1.9);
                resultMessage = `You won ${winAmount.toFixed(2)} SOL! Guessed in ${currentGuessCount} tries.`;
                modalTitleText = 'VICTORY!';
                playSound('win', winAmount); // Pass winAmount for conditional crowd cheer
                // Reduced confetti particle count by 30%
                confetti({ particleCount: 70, spread: 70, origin: { y: 0.6 } });

                for (let i = 0; i < 20; i++) {
                    const coin = document.createElement('div');
                    coin.className = 'sol-coin';
                    coin.style.cssText = `
                        position: fixed; top: -50px; left: ${Math.random() * 100}vw;
                        width: 40px; height: 40px;
                        background: url('https://cryptologos.cc/logos/solana-sol-logo.png') center/contain no-repeat;
                        z-index: 1000; filter: drop-shadow(0 0 10px gold);
                        animation: coinFall 1.5s ease-in forwards; animation-delay: ${Math.random() * 1}s;
                    `;
                    document.body.appendChild(coin);
                    setTimeout(() => coin.remove(), 3000);
                }

                document.addEventListener('mousemove', function followCursorConfetti(e) {
                    confetti({
                        particleCount: 3, startVelocity: 20, spread: 50, // Reduced particle count
                        origin: { x: e.clientX / window.innerWidth, y: e.clientY / window.innerHeight },
                        colors: ['#00ff00', '#ff4500', '#ffd700', '#00ffff', '#ff00ff'], scalar: 0.7
                    });
                    setTimeout(() => { document.removeEventListener('mousemove', followCursorConfetti); }, 5000);
                });

                addChatMessage('üî• @You: I won ' + winAmount.toFixed(2) + ' SOL!');
                playerCardYou.classList.add('winner');
                playerCardOpponent.classList.add('loser');
                updateHealthBar(opponentHealthFill, 0, false);
                userProfile.wins++;
                userProfile.streak++;
                userProfile.currentLossStreak = 0;
                userProfile.hasWonFirst = true; // Mark first win
                checkLevelUp(); // Check for level up after win
                const currentBalance = parseFloat(walletBalanceDisplay.textContent.split(': ')[1]) || 0;
                updateBalanceDisplay((currentBalance + winAmount) * 1000000000);

                if (userProfile.streak === 3) {
                    queueNotification('toast', { message: 'üî• 3-Win Streak! Free 0.01 SOL entry for your next duel!', type: 'success' });
                }
                trackEvent('duel_ended', 'game', 'win');

                localStorage.setItem('lastWin', 'true');
                localStorage.setItem('lastWinAmount', winAmount.toFixed(2).toString());
                localStorage.setItem('lastWinTime', Date.now().toString());

            } else if (timeLeft <= 0) {
                // Time-out condition for Higher/Lower mode
                if (gameMode === 'higher_lower') {
                    const playerRangeSize = playerRange.max - playerRange.min;
                    const opponentRangeSize = opponentRange.max - opponentRange.min;
                    playerWon = playerRangeSize < opponentRangeSize; // Player wins if their range is narrower
                    resultMessage = `Time‚Äôs up! ${playerWon ? 'You' : 'Opponent'} wins with a narrower range (${playerWon ? playerRangeSize : opponentRangeSize} vs ${playerWon ? opponentRangeSize : playerRangeSize}).`;
                } else {
                    resultMessage = `Time‚Äôs up! Closest guess wins. You: ${guessInput ? guessInput.value : 'N/A'}, Opponent: ${opponentGuessCount} tries.`;
                }
                modalTitleText = 'TIME UP!';
                playSound('lose');
                addChatMessage('‚è≥ Duel ended by time!');
                userProfile.losses++;
                userProfile.streak = 0;
                userProfile.currentLossStreak++;
                trackEvent('duel_ended', 'game', 'time_up');
            } else {
                resultMessage = `Opponent won! They guessed in ${opponentGuessCount} tries.`;
                modalTitleText = 'DEFEAT!';
                playSound('lose');
                document.body.classList.add('shake');
                document.body.addEventListener('animationend', () => {
                    document.body.classList.remove('shake');
                }, { once: true });
                addChatMessage('üíÄ @CryptoChad: Easy win!');
                playerCardYou.classList.add('loser');
                playerCardOpponent.classList.add('winner');
                updateHealthBar(playerHealthFill, 0, true);
                userProfile.losses++;
                userProfile.streak = 0;
                userProfile.currentLossStreak++;
                trackEvent('duel_ended', 'game', 'loss');
            }
            saveProfile();

            if (userProfile.currentLossStreak >= 3 && !userProfile.freeEntryAvailable) {
                userProfile.freeEntryAvailable = true;
                setTimeout(() => {
                    const freeEntryModal = document.createElement('div');
                    freeEntryModal.className = 'modal-overlay';
                    freeEntryModal.style.zIndex = '2000';
                    freeEntryModal.innerHTML = `
                        <div class="modal-content" style="border: 3px solid #00ff00; background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);">
                            <h3 style="color: #00ff00; text-shadow: 0 0 10px #00ff00;">DON'T GIVE UP!</h3>
                            <p style="font-size: 1.2rem; margin: 20px 0;">We've added a <span style="color: #00ff00; font-weight: bold; font-size: 1.5rem;">FREE 0.01 SOL ENTRY</span> to your account!</p>
                            <p style="margin-bottom: 20px; color: #aaa;">This is your comeback moment. Many winners started with a loss streak!</p>
                            <button style="background: linear-gradient(45deg, #00ff00, #00cc00); padding: 15px 30px; font-size: 1.2rem; margin-top: 10px; animation: pulse 1s infinite alternate;">PLAY FREE ROUND</button>
                        </div>
                    `;
                    document.body.appendChild(freeEntryModal);

                    const comebackSound = new Audio('https://www.myinstants.com/media/sounds/power-up.mp3');
                    comebackSound.volume = currentVolume; // Set volume
                    comebackSound.play().catch(e => console.error("Error playing comeback sound:", e));

                    const freeEntryButton = freeEntryModal.querySelector('button');
                    freeEntryButton.addEventListener('click', () => {
                        freeEntryModal.remove();
                        startDuel();
                    });
                    trackEvent('free_entry_offered', 'retention', 'loss_streak');
                }, 2000);
            }

            duelResult.textContent = resultMessage;
            showTransactionModal(modalTitleText, resultMessage + "<br><button id=\"share-win-button\" style=\"background: #1DA1F2; margin-top: 1rem; padding: 0.75rem 1.5rem; font-size: 1rem; color: #fff; border-radius: 5px; cursor: pointer; border: none;\">Share Win on X</button>");

            const shareWinButton = document.getElementById('share-win-button');
            if (shareWinButton) {
                shareWinButton.addEventListener('click', () => {
                    const tweetText = encodeURIComponent(`I just won ${playerWon ? (currentStakeAmount * (window.currentPayoutMultiplier || 1.9)).toFixed(2) + ' SOL' : 'a duel'} on SolDuel! üî• Join the Degen Arena: ${window.location.href} #SolDuel #Degen`);
                    window.open(`https://twitter.com/intent/tweet?text=${tweetText}`, '_blank');
                    trackEvent('share_win', 'social', playerWon ? 'win' : 'loss');
                });
            }
            updateLeaderboard(playerWon);

            if (!playerWon) {
                document.getElementById('modal-close-button').addEventListener('click', () => {
                    userProfile.behavioralData.chaseRatio =
                        (userProfile.behavioralData.chaseRatio * 5 + 1) / 6;
                    saveProfile();
                });

                if (userProfile.behavioralData.chaseRatio > 0.7 && stakeAmount >= 0.05) {
                    queueNotification('toast', { message: "Your comeback is coming! The next guess could be it!", type: "success" });
                }
            }
        }


        // --- Event Listeners and Game Logic ---

        // Wallet Connection
        connectWalletButton.addEventListener('click', async () => {
            await connectWallet();
        });

        // Volume Slider (Main)
        volumeSlider.addEventListener('input', () => {
            currentVolume = parseFloat(volumeSlider.value);
            if (backgroundAudio) {
                backgroundAudio.volume = 0.2 * currentVolume;
            }
            // Update sound icon based on volume
            if (currentVolume === 0) {
                soundIcon.classList.remove('fa-volume-up');
                soundIcon.classList.add('fa-volume-mute');
            } else {
                soundIcon.classList.remove('fa-volume-mute');
                soundIcon.classList.add('fa-volume-up');
            }
            trackEvent('set_volume', 'settings', currentVolume);
        });

        // Volume Slider (Dropdown)
        volumeSliderDropdown.addEventListener('input', () => {
            currentVolume = parseFloat(volumeSliderDropdown.value);
            // Sync main slider with dropdown slider
            volumeSlider.value = currentVolume;
            if (backgroundAudio) {
                backgroundAudio.volume = 0.2 * currentVolume;
            }
            // Update sound icon based on volume
            if (currentVolume === 0) {
                soundIconDropdown.classList.remove('fa-volume-up');
                soundIconDropdown.classList.add('fa-volume-mute');
            } else {
                soundIconDropdown.classList.remove('fa-volume-mute');
                soundIconDropdown.classList.add('fa-volume-up');
            }
            trackEvent('set_volume', 'settings', currentVolume);
        });


        // Help Button (Main)
        helpButton.addEventListener('click', () => {
            showModal('onboarding-modal');
        });

        // Stake Amount Select
        stakeAmountSelect.addEventListener('change', function() {
            stakeAmount = parseFloat(this.value);
            localStorage.setItem('lastStakeAmount', stakeAmount);

            const playStaggeredChipSounds = (count) => {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const chipSound = new Audio('https://www.soundjay.com/buttons/sounds/button-09a.mp3');
                        chipSound.volume = (0.7 + (Math.random() * 0.3)) * currentVolume; // Adjust by main volume
                        chipSound.preload = 'none'; // Lazy load audio
                        chipSound.play().catch(e => console.error("Error playing chip sound:", e));
                    }, i * 80);
                }
            };

            if (stakeAmount >= 0.1) {
                playStaggeredChipSounds(5);
            } else if (stakeAmount >= 0.05) {
                playStaggeredChipSounds(3);
            } else {
                playStaggeredChipSounds(2);
            }

            if (stakeAmount >= 0.1) {
                queueNotification('toast', { message: 'High stakes activated! Higher payout potential!', type: 'success' });
            }
        });

        /**
         * Connects to the Solana wallet.
         */
        async function connectWallet() {
            showLoading();
            try {
                const provider = await detectWallet();
                if (!provider) {
                    throw new Error('No Solana wallet detected. Please install Phantom or similar.');
                }

                const response = await provider.connect();
                userPublicKey = new PublicKey(response.publicKey.toBase58());

                isWalletConnected = true;
                connectWalletButton.style.display = 'none';
                walletInfoDiv.style.display = 'flex';
                walletAddressDisplay.textContent = `Wallet: ${userPublicKey.toBase58().substring(0, 6)}...${userPublicKey.toBase58().slice(-4)}`;

                const balance = await connection.getBalance(userPublicKey);
                updateBalanceDisplay(balance);
                updateNetworkStatus(true);
                playSound('connect');
                showToast('Wallet connected successfully!', 'success', true);
                trackEvent('wallet_connected', 'wallet', 'success');
                startDuel();
            } catch (error) {
                console.error('Wallet connection failed:', error);
                showToast('Wallet connection failed: ' + error.message, 'error', true);
                updateNetworkStatus(false);
                isWalletConnected = false;
                connectWalletButton.style.display = 'block';
                walletInfoDiv.style.display = 'none';
                trackEvent('wallet_connected', 'wallet', 'failed');
            } finally {
                hideLoading();
            }
        }

        /**
         * Updates the turn indicator display.
         */
        function updateTurnIndicator() {
            let turnIndicator = document.getElementById('turn-indicator');
            if (!turnIndicator) {
                turnIndicator = document.createElement('div');
                turnIndicator.id = 'turn-indicator';
                turnIndicator.style.cssText = `
                    position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
                    background: ${currentTurn === 'player' ? '#00ff00' : '#ff4500'};
                    color: #000; padding: 5px 15px; border-radius: 5px; font-weight: bold;
                `;
                document.getElementById('duel-arena').appendChild(turnIndicator);
            }
            turnIndicator.textContent = currentTurn === 'player' ? 'Your Turn' : 'Opponent‚Äôs Turn';
            turnIndicator.style.background = currentTurn === 'player' ? '#00ff00' : '#ff4500';
            turnIndicator.style.display = 'block'; // Ensure it's visible
        }

        /**
         * Starts a new duel.
         */
        function startDuel() {
            if (!isWalletConnected) {
                showToast('Please connect your wallet to start a duel.', 'error', true);
                return;
            }
            showLoading();
            duelStatus.textContent = 'Opponent found: @CryptoChad - 0.1 SOL pot';
            stakeSection.style.display = 'block';
            duelInProgress = true;
            timeLeft = 30;
            duelTimer.textContent = `00:${timeLeft.toString().padStart(2, '0')}`;
            targetNumber = Math.floor(Math.random() * 100) + 1;
            currentGuessCount = 0;
            opponentGuessCount = 0;
            duelResult.textContent = '';

            // Reset guess ranges for Classic mode
            minGuessRange = 1;
            maxGuessRange = 100;
            opponentMinGuessRange = 1;
            opponentMaxGuessRange = 100;

            playerCardYou.classList.remove('winner', 'loser');
            playerCardOpponent.classList.remove('winner', 'loser');
            updateHealthBar(playerHealthFill, 100, true);
            updateHealthBar(opponentHealthFill, 100, false);
            document.body.classList.remove('shake');

            const lastStakeAmount = localStorage.getItem('lastStakeAmount');
            if (lastStakeAmount) {
                stakeAmountSelect.value = lastStakeAmount;
            }

            streakProtectionAvailable = (userProfile.streak >= 2 && !userProfile.streakProtectionUsed);

            const rewardMultipliers = [1.5, 1.9, 2.0, 2.2, 3.0];
            const specialMultiplier = Math.random() < 0.3;
            if (specialMultiplier) {
                const selectedMultiplier = rewardMultipliers[Math.floor(Math.random() * rewardMultipliers.length)];
                window.currentPayoutMultiplier = selectedMultiplier;
                showToast(`üé∞ LUCKY MULTIPLIER: ${selectedMultiplier}x ACTIVATED!`, 'success');

                const multiplierBadge = document.createElement('div');
                multiplierBadge.className = 'multiplier-badge';
                multiplierBadge.style.cssText = `
                    position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
                    background: linear-gradient(45deg, gold, orange); color: black; font-weight: bold;
                    padding: 5px 15px; border-radius: 20px; z-index: 100; box-shadow: 0 0 15px gold;
                    animation: pulse 0.8s infinite alternate;
                `;
                multiplierBadge.innerHTML = `<span style="font-size: 1.2rem;">${selectedMultiplier}x</span> PAYOUT!`;
                document.getElementById('duel-arena').appendChild(multiplierBadge);
            } else {
                window.currentPayoutMultiplier = 1.9;
            }

            // First win guarantee for new users
            if (!userProfile.hasWonFirst && userProfile.wins === 0) {
                targetNumber = 50; // Rig the target number
                originalSimulateOpponentGuesses = simulateOpponentGuess; // Store original
                // Override opponent behavior to always guess wrong and give hints
                simulateOpponentGuess = function() {
                    if (!duelInProgress) return;
                    opponentGuessCount++;
                    // Opponent always guesses wrong, but close to target
                    let opponentGuess;
                    if (targetNumber > 50) {
                        opponentGuess = Math.floor(Math.random() * 40) + 1; // Guess low
                        opponentMaxGuessRange = Math.min(opponentMaxGuessRange, opponentGuess -1); // Narrow opponent's range
                        duelResult.textContent += `\nOpponent guessed ${opponentGuess} - Too low!`;
                    } else {
                        opponentGuess = Math.floor(Math.random() * 40) + 60; // Guess high
                        opponentMinGuessRange = Math.max(opponentMinGuessRange, opponentGuess + 1); // Narrow opponent's range
                        duelResult.textContent += `\nOpponent guessed ${opponentGuess} - Too high!`;
                    }
                    updateHealthBar(playerHealthFill, parseFloat(playerHealthFill.style.width) - 5, true); // Player takes minimal damage
                    updateGuessRangeIndicator(opponentMinGuessRange, opponentMaxGuessRange, opponentGuess, 'opponent');


                    if (opponentGuessCount >= 2 && opponentGuessCount <= 4) {
                        addChatMessage("üí¨ @CryptoChad: I'm getting close... maybe around 50?");
                    } else if (opponentGuessCount === 5) {
                        addChatMessage("üí¨ @DegenKing: This is harder than it looks!");
                    }

                    // End turn for opponent
                    currentTurn = 'player';
                    updateTurnIndicator();
                    if (guessButton) guessButton.disabled = false;
                };

                setTimeout(() => {
                    if (duelInProgress && currentGuessCount === 0) {
                        showToast("Hint: Try guessing 50!", "success");
                    }
                }, 20000);
            }

            // Set up the initial game mode UI
            if (gameMode === 'guess') {
                setupClassicGuessModeUI();
            } else if (gameMode === 'higher_lower') {
                startHigherLowerMode(); // This function already sets up its UI
            } 

            // Start the main duel timer
            clearInterval(timerInterval); // Clear any previous timer
            timerInterval = setInterval(() => {
                timeLeft--;
                duelTimer.textContent = `00:${timeLeft.toString().padStart(2, '0')}`;
                if (timeLeft <= 5) {
                    duelTimer.style.color = '#ff0000';
                    duelTimer.style.fontSize = '2rem';
                    duelTimer.style.animation = 'pulse 0.5s infinite alternate';
                } else if (timeLeft <= 10) {
                    duelTimer.style.color = '#ff9900';
                    duelTimer.style.fontSize = '1.9rem';
                    duelTimer.style.animation = 'pulse 0.8s infinite alternate';
                } else {
                    duelTimer.style.color = '#00ff00';
                    duelTimer.style.fontSize = '1.8rem';
                    duelTimer.style.animation = 'pulse 1s infinite alternate';
                }

                if (timeLeft <= 3) {
                    const urgencyFlash = document.createElement('div');
                    urgencyFlash.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background-color: rgba(255, 0, 0, 0.1); z-index: 999; pointer-events: none; animation: flash 0.3s;
                    `;
                    document.body.appendChild(urgencyFlash);
                    setTimeout(() => urgencyFlash.remove(), 300);
                }

                if (timeLeft <= 0) {
                    endDuel(); // End duel if time runs out
                }
            }, 1000);

            // Initial turn setup
            currentTurn = 'player';
            updateTurnIndicator();
            if (guessButton) guessButton.disabled = false; // Enable for player's first turn
            if (gameMode === 'higher_lower') {
                const higherButton = document.getElementById('higher-button');
                const lowerButton = document.getElementById('lower-button');
                if (higherButton) higherButton.disabled = false;
                if (lowerButton) lowerButton.disabled = false;
            }

            hideLoading();
            trackEvent('duel_started', 'game', 'new_duel');

            if (userProfile.enhancedNotifications) {
                setInterval(simulateTyping, 15000 + Math.random() * 20000);
            }
        }

        /**
         * Sets up the UI for Classic Guess Mode.
         */
        function setupClassicGuessModeUI() {
            gameMode = 'guess';
            guessSection.innerHTML = `
                <input type="number" id="guess-input" min="1" max="100" placeholder="Guess (1-100)" aria-label="Enter your guess between 1 and 100">
                <button id="guess-button" aria-label="Submit your guess">Guess</button>
                <p>Your Range: <span id="player-range-text">1 - 100</span></p>
                <div class="guess-range-container" id="player-guess-range-indicator">
                    <div class="guess-range-fill" id="player-guess-range-fill"></div>
                    <div class="guess-marker" id="player-guess-marker"></div>
                </div>
                <p>Opponent Range: <span id="opponent-range-text">1 - 100</span></p>
                <div class="guess-range-container" id="opponent-guess-range-indicator">
                    <div class="guess-range-fill" id="opponent-guess-range-fill" style="background: linear-gradient(to right, #ff4500, #ff0000);"></div>
                    <div class="guess-marker" id="opponent-guess-marker" style="background: #000;"></div>
                </div>
                `;
            // Re-bind elements after innerHTML update
            guessInput = document.getElementById('guess-input');
            guessButton = document.getElementById('guess-button');
            guessButton.addEventListener('click', handleGuessButtonClick);
            
            // Initialize range displays
            updateGuessRangeIndicator(minGuessRange, maxGuessRange, null, 'player');
            updateGuessRangeIndicator(opponentMinGuessRange, opponentMaxGuessRange, null, 'opponent');
            duelStatus.textContent = 'Guess the number!';
            guessInput.value = ''; // Clear input
        }

        /**
         * Handles the player's guess in Classic Guess Mode.
         */
        function handleGuessButtonClick() {
            if (currentTurn !== 'player' || !duelInProgress) {
                showToast('Wait for your turn!', 'error', true);
                return;
            }

            const guessTime = Date.now();
            if (window.lastGuessTime) {
                const thinkingTime = (guessTime - window.lastGuessTime) / 1000;
                userProfile.behavioralData.timeSpentThinking =
                    (userProfile.behavioralData.timeSpentThinking + thinkingTime) / 2;

                if (thinkingTime > 5 && Math.random() < 0.7) {
                    showToast("Trust your gut! Quick guessers often win more!", "success");
                }
            }
            window.lastGuessTime = guessTime;

            const guess = parseInt(guessInput.value);

            if (isNaN(guess) || guess < 1 || guess > 100) {
                showToast('Please enter a number between 1 and 100.', 'error', true);
                guessInput.classList.add('shake');
                guessInput.addEventListener('animationend', () => {
                    guessInput.classList.remove('shake');
                }, { once: true });
                return;
            }

            currentGuessCount++;
            playSound('guess');
            trackEvent('guess_submitted', 'duel', `Guess: ${guess}`);

            guessInput.classList.remove('shake', 'glow');

            if (guess === targetNumber) {
                endDuel(true);
            } else {
                const distance = Math.abs(guess - targetNumber);

                // Near Miss Vibration Trigger
                if (distance === 1) {
                    showToast("You were SO close!", "warning");
                    if (navigator.vibrate) {
                        navigator.vibrate(200); // Vibrate for 200ms
                    }
                }

                // Update player's guess range
                if (guess < targetNumber) {
                    minGuessRange = Math.max(minGuessRange, guess + 1);
                } else {
                    maxGuessRange = Math.min(maxGuessRange, guess - 1);
                }
                updateGuessRangeIndicator(minGuessRange, maxGuessRange, guess, 'player');
                document.getElementById('player-range-text').textContent = `${minGuessRange} - ${maxGuessRange}`;

                const feedback = document.createElement('div');
                feedback.className = 'guess-feedback';
                feedback.style.position = 'absolute';
                feedback.style.top = '70%';
                feedback.style.left = '50%';
                feedback.style.transform = 'translate(-50%, -50%)';
                feedback.style.fontSize = '2rem';
                feedback.style.zIndex = '100';
                feedback.style.transition = 'all 0.3s';
                if (distance <= 5) {
                    feedback.textContent = 'üî• BURNING HOT!';
                    feedback.style.color = '#ff4500';
                    feedback.style.textShadow = '0 0 10px red';
                } else if (distance <= 15) {
                    feedback.textContent = 'üî• Getting Warmer!';
                    feedback.style.color = 'orange';
                } else if (distance <= 30) {
                    feedback.textContent = 'üòê Lukewarm...';
                    feedback.style.color = 'yellow';
                } else {
                    feedback.textContent = '‚ùÑÔ∏è Ice Cold';
                    feedback.style.color = 'cyan';
                    feedback.style.textShadow = '0 0 10px blue';
                }
                document.getElementById('duel-arena').appendChild(feedback);
                setTimeout(() => feedback.remove(), 1500);

                if (distance <= 5 && distance > 0) {
                    playSound('nearMiss');
                    duelResult.innerHTML = '<span style="color: #ff4500; font-size: 1.3em; font-weight: bold; animation: pulse 0.5s infinite;">SO CLOSE! 1 MORE TRY!</span>';

                    const flashOverlay = document.createElement('div');
                    flashOverlay.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background-color: rgba(255, 0, 0, 0.2); z-index: 999; pointer-events: none; animation: flash 0.5s;
                    `;
                    document.body.appendChild(flashOverlay);
                    setTimeout(() => flashOverlay.remove(), 500);
                }

                if (distance <= 10) {
                    guessInput.classList.add('glow');
                } else {
                    guessInput.classList.add('shake');
                }
                guessInput.addEventListener('animationend', () => {
                    guessInput.classList.remove('shake', 'glow');
                }, { once: true });

                if (guess < targetNumber) {
                    duelResult.textContent = 'Too low! Try again.';
                } else {
                    duelResult.textContent = 'Too high! Try again.';
                }
                const healthReduction = Math.min(20, distance);
                const currentHealth = parseFloat(playerHealthFill.style.width) || 100;
                updateHealthBar(playerHealthFill, currentHealth - healthReduction, true);
            }
            guessInput.value = '';

            if (stakeAmount === userProfile.behavioralData.preferredStakeAmount) {
                if (Math.random() < 0.3 && stakeAmount < 0.1) {
                    showToast(`Players betting ${(stakeAmount * 2).toFixed(2)} SOL often see increased win rates!`, "success");
                }
            } else {
                userProfile.behavioralData.preferredStakeAmount = stakeAmount;
            }

            if (distance <= 5 && distance > 0) {
                userProfile.behavioralData.responseToNearMisses += 0.1;
                if (userProfile.behavioralData.responseToNearMisses > 0.5) {
                    setTimeout(() => {
                        const extraHeartbeat = new Audio('https://www.soundjay.com/human/heartbeat-01a.mp3');
                        extraHeartbeat.volume = currentVolume; // Set volume
                        extraHeartbeat.preload = 'none'; // Lazy load audio
                        extraHeartbeat.play().catch(e => console.error("Error playing heartbeat:", e));
                    }, 1200);
                    duelTimer.style.color = 'red';
                    duelTimer.style.animation = 'pulse 0.3s infinite';
                }
            }
            
            // End player's turn, start opponent's turn
            guessButton.disabled = true;
            currentTurn = 'opponent';
            updateTurnIndicator();
            setTimeout(simulateOpponentGuess, 1000); // Opponent guesses after 1 second
        }

        /**
         * Simulates the opponent's guess in Classic Guess Mode.
         */
        function simulateOpponentGuess() {
            if (!duelInProgress) return;

            opponentGuessCount++;
            let opponentGuess;

            // Opponent's guessing strategy: narrow down the range
            const currentOpponentRangeSize = opponentMaxGuessRange - opponentMinGuessRange + 1;
            if (currentOpponentRangeSize <= 0) { // Should not happen if logic is correct
                opponentGuess = Math.floor(Math.random() * 100) + 1;
            } else {
                // Opponent tries to guess within their current known range
                opponentGuess = Math.floor(Math.random() * currentOpponentRangeSize) + opponentMinGuessRange;
            }
            
            // Ensure opponent's guess is within 1-100
            opponentGuess = Math.max(1, Math.min(100, opponentGuess));

            duelResult.textContent += `\nOpponent guessed ${opponentGuess} - `;
            
            if (opponentGuess === targetNumber) {
                endDuel(false); // Opponent wins
            } else {
                if (opponentGuess < targetNumber) {
                    duelResult.textContent += 'Too low!';
                    opponentMinGuessRange = Math.max(opponentMinGuessRange, opponentGuess + 1);
                } else {
                    opponentMaxGuessRange = Math.min(opponentMaxGuessRange, opponentGuess - 1);
                }
                const distance = Math.abs(opponentGuess - targetNumber);
                // Opponent takes damage if their guess is wrong
                updateHealthBar(opponentHealthFill, parseFloat(opponentHealthFill.style.width) - Math.min(20, distance), false);
                if (parseFloat(opponentHealthFill.style.width) <= 0) {
                    endDuel(true); // Player wins if opponent health drops to 0
                    return;
                }
            }
            // Update opponent's range indicator
            updateGuessRangeIndicator(opponentMinGuessRange, opponentMaxGuessRange, opponentGuess, 'opponent');
            document.getElementById('opponent-range-text').textContent = `${opponentMinGuessRange} - ${opponentMaxGuessRange}`;

            // End opponent's turn, start player's turn
            currentTurn = 'player';
            updateTurnIndicator();
            if (guessButton) guessButton.disabled = false;
        }

        // Higher or Lower Mode Logic
        /**
         * Initializes and sets up the UI for Higher or Lower Mode.
         */
        function startHigherLowerMode() {
            gameMode = 'higher_lower';
            targetNumber = Math.floor(Math.random() * 100) + 1;
            playerRange = { min: 1, max: 100 };
            opponentRange = { min: 1, max: 100 };
            duelStatus.textContent = 'Higher or Lower Mode: Narrow your range to find the number!';
            
            // Dynamically set up the guess section for Higher/Lower
            guessSection.innerHTML = `
                <div id="player-range-display">
                    <p>Your Range: <span id="player-range-text">1 - 100</span></p>
                    <div class="guess-range-container" id="player-guess-range-indicator">
                        <div class="guess-range-fill" id="player-guess-range-fill"></div>
                    </div>
                </div>
                <div id="opponent-range-display" style="margin-top: 1rem;">
                    <p>Opponent Range: <span id="opponent-range-text">1 - 100</span></p>
                    <div class="guess-range-container" id="opponent-guess-range-indicator">
                        <div class="guess-range-fill" id="opponent-guess-range-fill" style="background: linear-gradient(to right, #ff4500, #ff0000);"></div>
                    </div>
                </div>
                <div style="margin-top: 1.5rem;">
                    <button id="higher-button" aria-label="Guess the number is higher than your current midpoint" style="padding: 0.5rem 1rem; background: #00ff00; color: #000; border: none; border-radius: 5px; margin-right: 0.5rem;">Higher</button>
                    <button id="lower-button" aria-label="Guess the number is lower than your current midpoint" style="padding: 0.5rem 1rem; background: #ff4500; color: #fff; border: none; border-radius: 5px;">Lower</button>
                </div>
            `;

            // Re-get references to the new buttons and elements
            const higherButton = document.getElementById('higher-button');
            const lowerButton = document.getElementById('lower-button');
            const playerRangeText = document.getElementById('player-range-text');
            const opponentRangeText = document.getElementById('opponent-range-text');
            const playerRangeFill = document.getElementById('player-guess-range-fill');
            const opponentRangeFill = document.getElementById('opponent-guess-range-fill');

            // Helper function to update a range indicator's visual fill and text
            function updateRangeIndicatorVisuals(range, fillElement, textElement) {
                const totalRange = 100;
                const fillWidth = ((range.max - range.min + 1) / totalRange) * 100; // +1 to include both ends
                const fillLeft = ((range.min - 1) / totalRange) * 100;
                
                fillElement.style.width = `${fillWidth}%`;
                fillElement.style.left = `${fillLeft}%`;
                textElement.textContent = `${range.min} - ${range.max}`;
            }

            // Initial updates for both ranges
            updateRangeIndicatorVisuals(playerRange, playerRangeFill, playerRangeText);
            updateRangeIndicatorVisuals(opponentRange, opponentRangeFill, opponentRangeText);

            // Attach event listeners for Higher/Lower buttons
            higherButton.addEventListener('click', () => handleHigherLowerGuess(true, higherButton, lowerButton, playerRangeFill, playerRangeText));
            lowerButton.addEventListener('click', () => handleHigherLowerGuess(false, higherButton, lowerButton, playerRangeFill, playerRangeText));

            // Ensure buttons are enabled for player's first turn
            higherButton.disabled = false;
            lowerButton.disabled = false;
        }

        /**
         * Handles a player's guess in Higher or Lower Mode.
         * @param {boolean} isHigher - True if player guessed 'Higher', false for 'Lower'.
         * @param {HTMLElement} higherButton - Reference to the Higher button.
         * @param {HTMLElement} lowerButton - Reference to the Lower button.
         * @param {HTMLElement} playerRangeFill - Player's range fill element.
         * @param {HTMLElement} playerRangeText - Player's range text element.
         */
        function handleHigherLowerGuess(isHigher, higherButton, lowerButton, playerRangeFill, playerRangeText) {
            if (currentTurn !== 'player' || !duelInProgress) {
                showToast('Wait for your turn!', 'error', true);
                return;
            }

            const midpoint = Math.floor((playerRange.min + playerRange.max) / 2);
            let correctGuess = false;

            if (isHigher) {
                if (targetNumber > midpoint) {
                    playerRange.min = midpoint + 1;
                    duelResult.textContent = `Correct! Number is higher than ${midpoint}.`;
                    correctGuess = true;
                } else {
                    playerRange.max = midpoint;
                    duelResult.textContent = `Wrong! Number is lower than ${midpoint}.`;
                }
            } else { // isLower
                if (targetNumber < midpoint) {
                    playerRange.max = midpoint - 1;
                    duelResult.textContent = `Correct! Number is lower than ${midpoint}.`;
                    correctGuess = true;
                } else {
                    playerRange.min = midpoint;
                    duelResult.textContent = `Wrong! Number is higher than ${midpoint}.`;
                }
            }

            if (correctGuess) {
                playSound('guess');
            } else {
                playSound('lose');
                updateHealthBar(playerHealthFill, parseFloat(playerHealthFill.style.width) - 10, true);
                if (parseFloat(playerHealthFill.style.width) <= 0) {
                    endDuel(false); // Player loses if health drops to 0
                    return;
                }
            }

            // Check if player found the exact number
            if (playerRange.min === targetNumber && playerRange.max === targetNumber) {
                endDuel(true); // Player wins
                return;
            }

            // Update player's range visuals
            updateRangeIndicatorVisuals(playerRange, playerRangeFill, playerRangeText);

            // End player's turn, start opponent's turn
            higherButton.disabled = true;
            lowerButton.disabled = true;
            currentTurn = 'opponent';
            updateTurnIndicator();
            setTimeout(() => simulateOpponentHigherLowerGuess(document.getElementById('opponent-guess-range-fill'), document.getElementById('opponent-range-text')), 1000);
        }

        /**
         * Simulates opponent's guess in Higher or Lower Mode.
         * @param {HTMLElement} opponentRangeFill - Opponent's range fill element.
         * @param {HTMLElement} opponentRangeText - Opponent's range text element.
         */
        function simulateOpponentHigherLowerGuess(opponentRangeFill, opponentRangeText) {
            if (!duelInProgress) return;

            const midpoint = Math.floor((opponentRange.min + opponentRange.max) / 2);
            let opponentCorrectGuess = false;
            let isHigherGuess = false;

            // Opponent's strategy: always guess towards the target number
            if (targetNumber > midpoint) {
                opponentRange.min = midpoint + 1;
                duelResult.textContent += `\nOpponent: Correct! Number is higher than ${midpoint}.`;
                opponentCorrectGuess = true;
                isHigherGuess = true;
            } else if (targetNumber < midpoint) {
                opponentRange.max = midpoint - 1;
                duelResult.textContent += `\nOpponent: Correct! Number is lower than ${midpoint}.`;
                opponentCorrectGuess = true;
                isHigherGuess = false;
            } else { // Opponent guessed the exact number
                opponentRange.min = targetNumber;
                opponentRange.max = targetNumber;
                opponentCorrectGuess = true;
            }
            
            if (!opponentCorrectGuess) { // If opponent guessed wrong (shouldn't happen with optimal strategy)
                updateHealthBar(opponentHealthFill, parseFloat(opponentHealthFill.style.width) - 10, false);
                if (parseFloat(opponentHealthFill.style.width) <= 0) {
                    endDuel(true); // Player wins if opponent health drops to 0
                    return;
                }
            }

            // Check if opponent found the exact number
            if (opponentRange.min === targetNumber && opponentRange.max === targetNumber) {
                endDuel(false); // Opponent wins
                return;
            }

            // Update opponent's range visuals
            updateRangeIndicatorVisuals(opponentRange, opponentRangeFill, opponentRangeText);

            // End opponent's turn, start player's turn
            currentTurn = 'player';
            updateTurnIndicator();
            document.getElementById('higher-button').disabled = false;
            document.getElementById('lower-button').disabled = false;
        }


        // Close transaction modal and prepare for new duel
        modalCloseButton.addEventListener('click', () => {
            hideTransactionModal();
            duelStatus.textContent = 'Waiting for opponent...';
            duelTimer.textContent = '00:30';
            duelResult.textContent = '';
            if (isWalletConnected) {
                startDuel();
            }
        });

        // Chat
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && chatInput.value.trim()) {
                addChatMessage(`${userProfile.username}: ${chatInput.value}`);
                chatInput.value = '';
                trackEvent('chat_message_sent', 'chat', 'user_message');
            }
        });

        /**
         * Adds a message to the chat window.
         * @param {string} message - The chat message.
         */
        function addChatMessage(message) {
            const li = document.createElement('li');
            li.innerHTML = `<span>${sanitizeInput(message)}</span>`;
            li.innerHTML += `
                <div class="reaction-buttons">
                    <button class="react-emoji" data-emoji="üî•">üî•</button>
                    <button class="react-emoji" data-emoji="üíÄ">üíÄ</button>
                    <button class="react-emoji" data-emoji="üöÄ">üöÄ</button>
                </div>
            `;
            chatMessages.appendChild(li);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            li.querySelectorAll('.react-emoji').forEach(button => {
                button.addEventListener('click', (e) => {
                    const emoji = e.target.dataset.emoji;
                    addChatMessage(`${userProfile.username}: ${emoji}`);
                    trackEvent('chat_reaction', 'chat', emoji);
                });
            });
        }

        // Leaderboard Update (Simulated)
        function updateLeaderboard(playerWon) {
            const leaderboardList = document.getElementById('leaderboard-list');
            if (playerWon) {
                leaderboardList.innerHTML = `
                    <li>1. ${userProfile.username} - ${userProfile.wins} wins</li>
                    <li>2. @DegenKing - 16 wins</li>
                    <li>3. @CryptoChad - 13 wins</li>
                `;
            } else {
                leaderboardList.innerHTML = `
                    <li>1. @DegenKing - 16 wins</li>
                    <li>2. @CryptoChad - 14 wins</li>
                    <li>3. ${userProfile.username} - ${userProfile.wins} wins</li>
                `;
            }
        }

        /**
         * Checks for level up and displays level up animation/rewards.
         */
        function checkLevelUp() {
            const oldLevel = userProfile.level;
            const newLevel = Math.floor(userProfile.wins / 2) + 1;

            if (newLevel > oldLevel) {
                userProfile.level = newLevel;
                updateLevelProgress(); // Update the progress bar immediately

                setTimeout(() => {
                    // Create level-up animation
                    const levelUpOverlay = document.createElement('div');
                    levelUpOverlay.className = 'modal-overlay';
                    levelUpOverlay.innerHTML = `
                        <div class="modal-content" style="border: 3px solid gold; background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);">
                            <h2>LEVEL UP!</h2>
                            <div class="level-number">${newLevel}</div>
                            <div class="level-rewards">
                                <p>Rewards Unlocked:</p>
                                <ul>
                                    ${newLevel % 5 === 0 ? '<li>New VIP Room Access!</li>' : ''}
                                    <li>+${(newLevel * 0.01).toFixed(2)} SOL Bonus</li>
                                    <li>+${newLevel}% Win Multiplier</li>
                                </ul>
                                <button id="claim-level-rewards">CLAIM REWARDS</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(levelUpOverlay);
                    playSound('level_up');

                    // Reduced confetti particle count by 30%
                    confetti({
                        particleCount: 70,
                        spread: 70,
                        origin: { y: 0.3 }
                    });

                    // Ensure keyboard navigation for the level-up modal button
                    const claimButton = document.getElementById('claim-level-rewards');
                    if (claimButton) {
                        claimButton.focus();
                    }

                    document.getElementById('claim-level-rewards').addEventListener('click', () => {
                        // Award the bonuses
                        const currentBalance = parseFloat(walletBalanceDisplay.textContent.split(': ')[1]) || 0;
                        updateBalanceDisplay((currentBalance + (newLevel * 0.01)) * 1000000000);

                        // Store level-specific win multiplier
                        window.levelMultiplier = 1 + (newLevel / 100);

                        levelUpOverlay.remove();

                        showToast(`Level ${newLevel} rewards claimed!`, 'success');
                    });
                }, 2000); // Delay before showing level up modal
            }
        }

        // --- Profile Management ---

        // Load profile from localStorage if available
        function loadProfile() {
            const savedProfile = localStorage.getItem('solDuelProfile');
            if (savedProfile) {
                userProfile = JSON.parse(savedProfile);
            }
            userProfile.behavioralData = userProfile.behavioralData || {
                preferredStakeAmount: null,
                responseToNearMisses: 0,
                timeSpentThinking: 0,
                chaseRatio: 0,
                lastActive: Date.now()
            };
            userProfile.currentLossStreak = userProfile.currentLossStreak || 0;
            userProfile.freeEntryAvailable = userProfile.freeEntryAvailable || false;
            userProfile.streakProtectionUsed = userProfile.streakProtectionUsed || false;
            userProfile.level = userProfile.level || 1; // Initialize level
            userProfile.enhancedNotifications = userProfile.enhancedNotifications !== undefined ? userProfile.enhancedNotifications : true; // Default to true
            userProfile.hasWonFirst = userProfile.hasWonFirst || false; // Initialize hasWonFirst

            updateProfileUI();
            updateLevelProgress(); // Update progress bar on load
        }

        // Save profile to localStorage
        function saveProfile() {
            localStorage.setItem('solDuelProfile', JSON.stringify(userProfile));
            updateProfileUI();

            const streakBadge = document.getElementById('player-streak-badge');
            if (userProfile.streak >= 2) {
                streakBadge.style.display = 'block';
                streakBadge.textContent = `üî•${userProfile.streak}`;
                if (userProfile.streak >= 5) {
                    streakBadge.style.background = 'linear-gradient(45deg, gold, orange)';
                    streakBadge.style.transform = 'scale(1.2)';
                }
            } else {
                streakBadge.style.display = 'none';
            }
        }

        // Update UI with profile data
        function updateProfileUI() {
            document.querySelector('#player-card-you .username').textContent = userProfile.username;
            document.querySelector('#player-card-you .avatar').src = userProfile.avatar;
            avatarPreviewImg.src = userProfile.avatar;
            profileUsernameInput.value = userProfile.username.replace('@', '');
            profileBioInput.value = userProfile.bio;
            toggleEnhancedNotifications.checked = userProfile.enhancedNotifications;

            // Update VIP room lock status based on level
            if (userProfile.level >= 5) {
                if (vipRoom1Lock) vipRoom1Lock.style.display = 'none';
            } else {
                if (vipRoom1Lock) vipRoom1Lock.textContent = `Unlock at Level 5 (Current: ${userProfile.level})`;
            }
            if (userProfile.level >= 10) {
                if (vipRoom2Lock) vipRoom2Lock.style.display = 'none';
            } else {
                if (vipRoom2Lock) vipRoom2Lock.textContent = `Unlock at Level 10 (Current: ${userProfile.level})`;
            }
            // VIP Room 3 "Invite Only" remains hardcoded.
        }

        // Open Profile Modal
        profileButton.addEventListener('click', () => {
            showModal('profile-modal');
        });

        // Close Profile Modal (by clicking outside or pressing ESC)
        profileModal.addEventListener('click', (e) => {
            if (e.target === profileModal) {
                hideModal('profile-modal');
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && profileModal.style.display === 'flex') {
                hideModal('profile-modal');
            }
        });

        // Avatar Preview
        profileAvatarInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    avatarPreviewImg.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Save Profile
        saveProfileButton.addEventListener('click', () => {
            const newUsername = sanitizeInput(profileUsernameInput.value.trim());
            const newBio = sanitizeInput(profileBioInput.value.trim());
            const newAvatar = avatarPreviewImg.src;
            const newEnhancedNotifications = toggleEnhancedNotifications.checked;

            if (!newUsername) {
                showToast('Username cannot be empty.', 'error', true);
                return;
            }

            userProfile.username = `@${newUsername}`;
            userProfile.avatar = newAvatar;
            userProfile.bio = newBio;
            userProfile.enhancedNotifications = newEnhancedNotifications;
            saveProfile();
            hideModal('profile-modal');
            showToast('Profile updated!', 'success', true);
            trackEvent('save_profile', 'profile', 'updated');
        });

        // View Public Profile from Chat
        chatMessages.addEventListener('click', (e) => {
            const target = e.target.closest('li span');
            if (target && target.textContent.includes('@')) {
                const username = target.textContent.split(':')[0].trim();
                publicProfileUsername.textContent = username;
                publicProfileAvatar.src = username === userProfile.username ? userProfile.avatar : 'https://placehold.co/60x60/ff4500/ffffff?text=OPP';
                publicProfileBio.textContent = username === userProfile.username ? userProfile.bio : 'A fierce degen competitor!';
                publicProfileWins.textContent = username === userProfile.username ? userProfile.wins : 13;
                publicProfileLosses.textContent = username === userProfile.username ? userProfile.losses : 5;
                publicProfileStreak.textContent = username === userProfile.username ? userProfile.streak : 3;
                publicProfileLevel.textContent = username === userProfile.username ? userProfile.level : 5; // Example level for opponent
                showModal('public-profile-modal');
                trackEvent('view_public_profile', 'profile', username);
            }
        });

        // Close Public Profile Modal
        closePublicProfileButton.addEventListener('click', () => {
            hideModal('public-profile-modal');
        });
        publicProfileModal.addEventListener('click', (e) => {
            if (e.target === publicProfileModal) {
                hideModal('public-profile-modal');
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && publicProfileModal.style.display === 'flex') {
                hideModal('public-profile-modal');
            }
        });

        // --- Network Status Monitoring ---
        async function checkNetworkStatus() {
            try {
                const response = await fetch('https://api.devnet.solana.com', { method: 'HEAD', mode: 'no-cors' });
                updateNetworkStatus(true);
            } catch (error) {
                updateNetworkStatus(false);
                showToast('Network disconnected. Please check your connection.', 'error', true);
                trackEvent('network_status', 'system', 'disconnected');
            }
        }

        // --- Demo Duel Logic ---
        function startDemoDuel() {
            onboardingModal.style.display = 'none';
            duelStatus.textContent = 'Demo Mode: Guess the number!';
            stakeSection.style.display = 'none'; // Hide stake section in demo
            timeLeft = 15;
            targetNumber = 50; // Fixed for demo
            duelTimer.textContent = `00:${timeLeft.toString().padStart(2, '0')}`;
            showToast('Try guessing between 1 and 100!', 'success', true);
            currentGuessCount = 0;

            // Setup classic guess mode UI for demo
            setupClassicGuessModeUI();
            if (guessInput) guessInput.value = ''; // Clear input
            if (guessButton) guessButton.disabled = false; // Enable for demo

            clearInterval(timerInterval); // Clear any existing timer
            timerInterval = setInterval(() => {
                timeLeft--;
                duelTimer.textContent = `00:${timeLeft.toString().padStart(2, '0')}`;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    showToast('Demo ended! Connect your wallet to play for real.', 'success', true);
                    duelStatus.textContent = 'Waiting for opponent...';
                    guessSection.style.display = 'none';
                    if (!isWalletConnected) {
                        if (guessButton) guessButton.disabled = true; // Disable after demo
                        if (guessInput) guessInput.disabled = true;
                    }
                }
            }, 1000);
        }

        // --- Initialization ---
        // Initial network status check (simulated)
        updateNetworkStatus(true);
        setInterval(checkNetworkStatus, 30000);

        // Simulate spectator count update
        setInterval(updateLiveStatusBar, 10000); // Updated to use liveStatusBar
        updateLiveStatusBar();

        // Initialize Profile
        loadProfile();

        // Emoji Picker setup
        emojiToggle.addEventListener('click', () => {
            emojiPicker.style.display = emojiPicker.style.display === 'none' ? 'block' : 'none';
            trackEvent('toggle_emoji_picker', 'chat', emojiPicker.style.display === 'block' ? 'open' : 'close');
        });
        emojiPicker.addEventListener('emoji-click', (event) => {
            chatInput.value += event.detail.unicode;
            emojiPicker.style.display = 'none';
        });

        // Show last win popup after a short delay
        setTimeout(() => queueNotification('lastWin', {}), 3000);

        // Update active guesser count frequently
        setInterval(updateGuessPill, 1000); // Updated to use guessPill
        updateGuessPill();

        // Add jackpot button handler
        document.getElementById('jackpot-button').addEventListener('click', () => {
            if (!isWalletConnected) {
                showTransactionModal('MEGA JACKPOT EVENT', 'Connect your wallet to join the 5 SOL MEGA JACKPOT event!<br><br>Over 100 players already participating!');
                connectWalletButton.click();
            } else {
                showTransactionModal('MEGA JACKPOT EVENT', 'Entry fee: 0.1 SOL<br><br>Current Jackpot: 5.72 SOL<br>Your winning odds: 1/42<br><br><button style="background: gold; color: black; border: none; padding: 10px 20px; border-radius: 5px; margin-top: 10px; cursor: pointer; font-weight: bold;">JOIN FOR 0.1 SOL</button>');
            }
            trackEvent('jackpot_click', 'fomo', 'banner');
        });

        // Start the fake live win notifications cycle
        scheduleNextWinNotification();

        // Set up FOMO countdown
        setInterval(updateJackpotCountdown, 1000);
        updateJackpotCountdown();

        // Add pull-to-refresh reward system
        let lastY = 0;
        let pullDistance = 0;
        let isPulling = false;
        let pullThreshold = 100;
        let pullRefreshCooldown = false;
        document.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                lastY = e.touches[0].clientY;
                isPulling = true;
            }
        });
        document.addEventListener('touchmove', (e) => {
            if (!isPulling || pullRefreshCooldown) return;

            const currentY = e.touches[0].clientY;
            const deltaY = currentY - lastY;

            if (deltaY > 0 && window.scrollY === 0) {
                pullDistance += deltaY / 3;
                lastY = currentY;

                let pullIndicator = document.getElementById('pull-refresh-indicator');
                if (!pullIndicator) {
                    pullIndicator = document.createElement('div');
                    pullIndicator.id = 'pull-refresh-indicator';
                    pullIndicator.style.cssText = `
                        position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
                        background: rgba(0, 255, 0, 0.8); color: black; padding: 10px 20px;
                        border-radius: 30px; font-weight: bold; z-index: 9999; opacity: 0; transition: opacity 0.3s;
                    `;
                    document.body.appendChild(pullIndicator);
                    setTimeout(() => pullIndicator.style.opacity = '1', 10);
                }

                const progressPercent = Math.min(100, (pullDistance / pullThreshold) * 100);
                pullIndicator.textContent = progressPercent < 90
                    ? `Pull down for surprise reward (${Math.floor(progressPercent)}%)`
                    : 'Release for reward!';

                pullIndicator.style.background = progressPercent < 90
                    ? 'rgba(0, 255, 0, 0.8)'
                    : 'rgba(255, 215, 0, 0.8)';
            }
        });
        document.addEventListener('touchend', () => {
            if (!isPulling || pullRefreshCooldown) {
                isPulling = false;
                pullDistance = 0;
                return;
            }

            const pullIndicator = document.getElementById('pull-refresh-indicator');
            if (pullIndicator) {
                pullIndicator.style.opacity = '0';
                setTimeout(() => pullIndicator.remove(), 300);
            }

            if (pullDistance >= pullThreshold) {
                const rewards = [
                    { name: "0.01 SOL Bonus", chance: 45, value: 0.01 },
                    { name: "Free Entry", chance: 30, value: 0, type: "free_entry" },
                    { name: "1.5x Multiplier", chance: 15, value: 0, type: "multiplier" },
                    { name: "0.05 SOL Jackpot", chance: 9, value: 0.05 },
                    { name: "0.5 SOL MEGA", chance: 1, value: 0.5 }
                ];

                const rand = Math.random() * 100;
                let cumulative = 0;
                let selectedReward;

                for (const reward of rewards) {
                    cumulative += reward.chance;
                    if (rand <= cumulative) {
                        selectedReward = reward;
                        break;
                    }
                }

                const rewardModal = document.createElement('div');
                rewardModal.className = 'modal-overlay';
                rewardModal.innerHTML = `
                    <div class="modal-content" style="border: 3px solid gold; background: linear-gradient(to bottom, #1a1a1a, #0a0a0a);">
                        <h3 style="color: gold; text-shadow: 0 0 10px gold; font-size: 1.5rem;">SURPRISE REWARD!</h3>
                        <div style="height: 100px; position: relative; margin: 20px 0; overflow: hidden;">
                            <div id="slot-machine" style="position: absolute; top: 0; left: 0; width: 100%; transition: top 3s cubic-bezier(0.23, 1, 0.32, 1);">
                                ${rewards.map(r => `<div style="height: 100px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; font-weight: bold; color: white;">${r.name}</div>`).join('')}
                            </div>
                        </div>
                        <button style="background: gold; color: black; padding: 10px 20px; border-radius: 5px; border: none; font-weight: bold; font-size: 1.1rem; cursor: pointer; margin-top: 20px;">CLAIM</button>
                    </div>
                `;
                document.body.appendChild(rewardModal);

                setTimeout(() => {
                    const slotMachine = document.getElementById('slot-machine');
                    const rewardIndex = rewards.findIndex(r => r === selectedReward);
                    slotMachine.style.top = `-${rewardIndex * 100}px`;

                    playSound('jackpot_spin');

                    if (selectedReward.value >= 0.05) {
                        setTimeout(() => {
                            confetti({ particleCount: 70, spread: 70, origin: { y: 0.6 } });
                        }, 3000);
                    }
                }, 100);

                const claimButton = rewardModal.querySelector('button');
                claimButton.addEventListener('click', () => {
                    rewardModal.remove();

                    if (selectedReward.value > 0) {
                        const currentBalance = parseFloat(walletBalanceDisplay.textContent.split(': ')[1]) || 0;
                        updateBalanceDisplay((currentBalance + selectedReward.value) * 1000000000);
                        showToast(`Added ${selectedReward.value} SOL to your balance!`, 'success', true);
                    } else if (selectedReward.type === "free_entry") {
                        userProfile.freeEntryAvailable = true;
                        showToast('Free entry available for your next duel!', 'success', true);
                    } else if (selectedReward.type === "multiplier") {
                        window.bonusMultiplier = 1.5;
                        showToast('1.5x multiplier applied to your next win!', 'success', true);
                    }
                    trackEvent('pull_reward_claimed', 'rewards', selectedReward.name);
                });

                pullRefreshCooldown = true;
                setTimeout(() => { pullRefreshCooldown = false; }, 3600000);
                trackEvent('pull_reward_triggered', 'rewards', 'refresh');
            }
            isPulling = false;
            pullDistance = 0;
        });

        // Returning user detection
        const daysSinceLastActive = (Date.now() - userProfile.behavioralData.lastActive) / (1000 * 60 * 60 * 24);
        if (daysSinceLastActive > 1) {
            queueNotification('welcomeBack', {});
        }
        userProfile.behavioralData.lastActive = Date.now();

        // Add click handler for VIP room upgrade button
        document.querySelector('#vip-rooms button').addEventListener('click', () => {
            showTransactionModal('VIP Access', 'Upgrade to VIP to access exclusive high-stakes rooms!<br><br>Special offer: 50% OFF today only!<br><br><button style="background: gold; color: black; border: none; padding: 10px 20px; border-radius: 5px; margin-top: 10px; cursor: pointer; font-weight: bold;">GET VIP FOR 0.5 SOL</button>');
            trackEvent('upgrade_click', 'vip', 'rooms');
        });

        // Onboarding logic - Modified to use DOMContentLoaded and localStorage
        document.addEventListener('DOMContentLoaded', () => {
            const seenIntro = localStorage.getItem('seenOnboarding');
            if (!seenIntro) {
                const onboardingModal = document.getElementById('onboarding-modal');
                if (onboardingModal) onboardingModal.style.display = 'flex';
                localStorage.setItem('seenOnboarding', 'true');
                trackEvent('onboarding_start', 'onboarding', 'first_visit');
            }
        });

        startOnboardingButton.addEventListener('click', () => {
            onboardingModal.style.display = 'none';
            trackEvent('onboarding_complete', 'onboarding', 'button_click');
            // Optionally, connect wallet automatically or prompt user
            if (!isWalletConnected) {
                connectWallet();
            } else {
                startDuel();
            }
        });

        startDemoDuelButton.addEventListener('click', () => {
            startDemoDuel();
            trackEvent('demo_duel_started', 'onboarding', 'button_click');
        });

        // Game Mode Toggle - Now only cycles between Classic and Higher/Lower
        const modeToggle = document.getElementById('mode-toggle');
        modeToggle.addEventListener('click', () => {
            // Clear any existing turn timers when switching modes (though not used in these two modes)
            clearInterval(turnTimer); 

            if (gameMode === 'guess') {
                gameMode = 'higher_lower';
                modeToggle.textContent = 'Switch to Classic Guess Mode';
                startHigherLowerMode();
            } else if (gameMode === 'higher_lower') {
                gameMode = 'guess';
                modeToggle.textContent = 'Switch to Higher/Lower Mode';
                setupClassicGuessModeUI(); // Revert to classic guess UI
            }
            // Reset common game state variables for new mode
            duelInProgress = true; // Assume duel starts with mode switch
            timeLeft = 30; // Reset timer
            duelTimer.textContent = `00:${timeLeft.toString().padStart(2, '0')}`;
            targetNumber = Math.floor(Math.random() * 100) + 1;
            currentGuessCount = 0;
            opponentGuessCount = 0;
            duelResult.textContent = '';

            // Reset ranges for new mode
            minGuessRange = 1;
            maxGuessRange = 100;
            opponentMinGuessRange = 1;
            opponentMaxGuessRange = 100;
            playerRange = { min: 1, max: 100 }; // For Higher/Lower
            opponentRange = { min: 1, max: 100 }; // For Higher/Lower

            currentTurn = 'player'; // Player always starts
            updateTurnIndicator();
            guessSection.style.display = 'block'; // Ensure guess section is visible
            
            // Re-enable buttons based on the new mode's initial state
            if (gameMode === 'guess') {
                if (guessButton) guessButton.disabled = false;
            } else if (gameMode === 'higher_lower') {
                const higherButton = document.getElementById('higher-button');
                const lowerButton = document.getElementById('lower-button');
                if (higherButton) higherButton.disabled = false;
                if (lowerButton) lowerButton.disabled = false;
            }
            updateGuessPill(); // Update guess pill with new mode
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Spacebar for guess/higher/lower button
            if (e.code === 'Space' && duelInProgress && currentTurn === 'player') {
                e.preventDefault(); // Prevent scrolling
                if (gameMode === 'guess' && guessInput && guessButton && !guessButton.disabled) {
                    guessButton.click();
                } else if (gameMode === 'higher_lower') {
                    const higherButton = document.getElementById('higher-button');
                    const lowerButton = document.getElementById('lower-button');
                    if (higherButton && !higherButton.disabled) {
                        higherButton.click(); // Default to higher for space, or could be last clicked
                    } else if (lowerButton && !lowerButton.disabled) {
                        lowerButton.click();
                    }
                }
            }
            // H for help button
            if (e.key === 'h' || e.key === 'H') {
                helpButton.click();
            }
        });

        // --- Mobile-Specific Event Listeners ---
        // Header Menu Toggle
        headerMenuToggle.addEventListener('click', () => {
            headerDropdown.style.display = 'flex';
            // Sync dropdown volume slider with main one
            volumeSliderDropdown.value = volumeSlider.value;
            if (volumeSliderDropdown.value === '0') {
                soundIconDropdown.classList.remove('fa-volume-up');
                soundIconDropdown.classList.add('fa-volume-mute');
            } else {
                soundIconDropdown.classList.remove('fa-volume-mute');
                soundIconDropdown.classList.add('fa-volume-up');
            }
        });

        closeHeaderDropdown.addEventListener('click', () => {
            headerDropdown.style.display = 'none';
        });

        openProfileFromDropdown.addEventListener('click', () => {
            hideModal('header-dropdown');
            profileButton.click(); // Trigger main profile button logic
        });

        openHelpFromDropdown.addEventListener('click', () => {
            hideModal('header-dropdown');
            helpButton.click(); // Trigger main help button logic
        });

        // Touch event handling for buttons (Higher/Lower mode)
        document.addEventListener('DOMContentLoaded', () => {
            const higherButton = document.getElementById('higher-button');
            const lowerButton = document.getElementById('lower-button');
            if (higherButton) {
                higherButton.addEventListener('touchstart', function(e) {
                    e.preventDefault(); // Prevent scrolling while tapping
                    this.click(); // Trigger click event
                });
            }
            if (lowerButton) {
                lowerButton.addEventListener('touchstart', function(e) {
                    e.preventDefault(); // Prevent scrolling while tapping
                    this.click(); // Trigger click event
                });
            }
             if (guessButton) { // For classic mode guess button
                guessButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    this.click();
                });
            }
        });


        // Background Music Only After Tap - Consolidated Listener
        document.body.addEventListener("click", () => {
            if (!hasUserInteracted) {
                hasUserInteracted = true;
                playBackgroundMusic();
            }
        }, { once: true });


        // Daily Bonus Trigger - Check on load
        document.addEventListener('DOMContentLoaded', () => {
            const lastClaimedDate = localStorage.getItem("claimedDailyBonusDate");
            const today = new Date().toDateString();

            if (!lastClaimedDate || lastClaimedDate !== today) {
                showModal("daily-bonus-modal");
            }

            document.getElementById('claim-daily-bonus-button').addEventListener('click', () => {
                const currentBalance = parseFloat(walletBalanceDisplay.textContent.split(': ')[1]) || 0;
                updateBalanceDisplay((currentBalance + 0.005) * 1000000000);
                localStorage.setItem("claimedDailyBonusDate", today);
                hideModal("daily-bonus-modal");
                showToast('Daily bonus claimed!', 'success', true);
            });
        });


        // Initial calls (only those not handled by DOMContentLoaded)
        // checkOnboarding(); // Now handled by DOMContentLoaded listener
        // Removed direct playSound('background_loop') here. It will be triggered by user interaction.

        // Implement a toggle for animations (UI for this would be in settings)
        const disableAnimations = localStorage.getItem('disableAnimations') === 'true';
        if (disableAnimations) {
            document.body.classList.add('no-animations');
        }
    </script>
</body>
</html>
